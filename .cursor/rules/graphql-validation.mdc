---
description: "GraphQL input types, Zod validation schemas, and validation patterns. Input types define API contracts, Zod schemas provide runtime validation, and schema.graphql ensures GraphQL consistency."
globs:
  - "src/graphql/inputs/**/*.ts"
  - "src/graphql/resolvers/**/*.ts"
alwaysApply: false
---

# GraphQL Input & Validation Rules

This API uses a three-layer validation system: TypeScript input types for compile-time safety, Zod schemas for runtime validation, and GraphQL schema for API contract consistency.

## Architecture Overview

```
┌─────────────────────────────────────┐
│  schema.graphql                    │  ← GraphQL API contract
│  (Input types defined here)        │
├─────────────────────────────────────┤
│  graphql/inputs/*.ts                │  ← TypeScript interfaces
│  (Type function parameters)         │
├─────────────────────────────────────┤
│  graphql/inputs/schemas/*.ts       │  ← Zod validation schemas
│  (Runtime validation)               │
└─────────────────────────────────────┘
         ↓
    validateInput()
    (lib/validation.ts)
```

## Input Types (`src/graphql/inputs/`)

Input types are TypeScript interfaces that define the shape of data passed to service functions.

### File Organization

One file per entity: `{entity}Inputs.ts`

```typescript
// src/graphql/inputs/businessInputs.ts
export interface BusinessScalarFields {
  name: string;
  description?: string;
  website?: string;
  biography?: string;
  mediaLinks?: MediaLink[];
}

export interface BusinessCreateWithOptionalIdsInput
  extends BusinessScalarFields {
  ownerIds?: string[];
  productIds?: string[];
  sponsorEpisodeIds?: string[];
}

export interface BusinessUpdateWithOptionalIdsInput
  extends BusinessScalarUpdateFields {
  id: string;
  ownerIds?: string[];
  productIds?: string[];
}
```

### Naming Conventions

- **Scalar fields**: `{Entity}ScalarFields` - Base fields without relations
- **Create inputs**: `{Entity}CreateWithOptionalIdsInput` - Create with optional relation IDs
- **Update inputs**: `{Entity}UpdateWithOptionalIdsInput` - Update with optional fields + id
- **Relation inputs**: `{Entity}UpdateRelationFieldsInput` - Update only relations
- **Nested inputs**: `{Entity}{Relation}NestedInput` - For nested entity creation

**Reference**: @src/graphql/inputs/episodeInputs.ts

## Zod Validation Schemas (`src/graphql/inputs/schemas/`)

Zod schemas provide runtime validation and must match input types exactly.

### File Organization

One file per entity: `{entity}Schemas.ts`

```typescript
// src/graphql/inputs/schemas/businessSchemas.ts
import { z } from "zod";
import {
  ObjectIdSchema,
  ObjectIdArraySchema,
  OptionalUrlSchema,
} from "../../../lib/validation.js";

export const BusinessScalarFieldsSchema = z.object({
  name: z.string().min(1, "Business name is required").max(200),
  description: z.string().max(5000).optional(),
  website: OptionalUrlSchema,
  biography: z.string().max(10000).optional(),
  mediaLinks: z.array(MediaLinkSchema).optional(),
});

export const BusinessCreateWithOptionalIdsInputSchema =
  BusinessScalarFieldsSchema.extend({
    ownerIds: ObjectIdArraySchema.optional(),
    productIds: ObjectIdArraySchema.optional(),
  });

export const BusinessUpdateWithOptionalIdsInputSchema =
  BusinessScalarFieldsSchema.partial().extend({ id: ObjectIdSchema });
```

### Schema Patterns

**Base schema + extend**:

```typescript
const BaseSchema = z.object({ name: z.string() });
const CreateSchema = BaseSchema.extend({
  ownerIds: ObjectIdArraySchema.optional(),
});
```

**Partial for updates**:

```typescript
const UpdateSchema = BaseSchema.partial().extend({ id: ObjectIdSchema });
```

**Refinements for complex validation**:

```typescript
const NestedInputSchema = z
  .object({
    id: ObjectIdSchema.optional(),
    name: z.string().optional(),
  })
  .refine((data) => data.id || data.name, {
    message: "Either 'id' or 'name' must be provided",
    path: ["name"],
  });
```

**Reference**: @src/graphql/inputs/schemas/episodeSchemas.ts

### Shared Validators

Use shared validators from `lib/validation.ts`:

- `ObjectIdSchema` - Validates MongoDB ObjectId format
- `ObjectIdArraySchema` - Array of ObjectIds
- `OptionalObjectIdSchema` - Optional ObjectId
- `UrlSchema` - Valid URL or empty string
- `OptionalUrlSchema` - Optional URL

**Reference**: @src/lib/validation.ts

## Validation Function (`src/lib/validation.ts`)

The `validateInput()` function validates inputs using Zod schemas:

```typescript
import { validateInput } from "../lib/validation.js";
import { BusinessCreateSchema } from "../graphql/inputs/schemas/businessSchemas.js";
import { BusinessCreateInput } from "../graphql/inputs/businessInputs.js";

async createBusiness(input: BusinessCreateInput): Promise<IBusiness> {
  // Validates and throws Errors.validation if invalid
  const validated = validateInput(
    BusinessCreateSchema,
    input,
    "BusinessCreateInput"
  );

  // validated is now type-safe and matches the schema
  return await Business.create(validated);
}
```

**Rules**:

- Always validate inputs before use
- Pass the schema, input, and a descriptive field name
- `validateInput()` throws `Errors.validation()` on failure
- Use `validateInputSafe()` if you need to handle validation errors without throwing

**Reference**: @src/lib/validation.ts

## GraphQL Schema (`src/graphql/schema.graphql`)

The GraphQL schema defines input types that match TypeScript interfaces for API consistency.

**Pattern**:

- GraphQL input types should match TypeScript input interfaces
- Field types must align (String, Int, [String], etc.)
- Required vs optional fields must match

**Note**: The `schema.graphql` file is large and maintained separately. When adding new inputs:

1. Add TypeScript interface in `graphql/inputs/`
2. Add Zod schema in `graphql/inputs/schemas/`
3. Add GraphQL input type in `schema.graphql`

## GraphQL Operations (`src/graphql/operations/`)

GraphQL operation files define queries and mutations used for SDK generation.

### Purpose

- **SDK Generation**: TypeScript and Python SDKs are generated from these operations
- **Type Safety**: Ensures SDK methods match actual GraphQL operations
- **Documentation**: Serves as examples of how to use the API

### File Structure

- `queries.graphql` - All query operations
- `mutations.graphql` - All mutation operations

**Example**:

```graphql
# mutations.graphql
mutation CreateBusiness($input: BusinessCreateWithIdsInput!) {
  createBusiness(input: $input) {
    id
    name
    description
  }
}
```

**Rules**:

- Keep operations in sync with resolvers
- Include all fields that SDKs need
- Update operations when adding new resolvers

**Reference**: @src/graphql/operations/

## Validation Flow

### In Resolvers

```typescript
// Resolver receives GraphQL input
createBusiness: async (_parent, args, ctx) => {
  requireAdmin(ctx);
  // args.input is typed as BusinessCreateInput (from input types)
  return await createBusinessWithRelations(args.input);
};
```

### In Services

```typescript
// Service validates and uses input
async createBusinessWithRelations(
  input: BusinessCreateRelationsInput // TypeScript interface
): Promise<IBusiness> {
  // Validate using Zod schema
  const validated = validateInput(
    BusinessCreateWithRelationsInputSchema, // Zod schema
    input,
    "BusinessCreateRelationsInput"
  );

  // validated is type-safe and validated
  // ... use validated input
}
```

## Rules for Adding New Inputs

### Step 1: Define TypeScript Interface

```typescript
// src/graphql/inputs/businessInputs.ts
export interface BusinessNewOperationInput {
  name: string;
  description?: string;
  ownerIds?: string[];
}
```

### Step 2: Create Zod Schema

```typescript
// src/graphql/inputs/schemas/businessSchemas.ts
export const BusinessNewOperationInputSchema = z.object({
  name: z.string().min(1).max(200),
  description: z.string().max(5000).optional(),
  ownerIds: ObjectIdArraySchema.optional(),
});
```

### Step 3: Add to GraphQL Schema

```graphql
# src/graphql/schema.graphql
input BusinessNewOperationInput {
  name: String!
  description: String
  ownerIds: [ID!]
}
```

### Step 4: Use in Service

```typescript
async newOperation(input: BusinessNewOperationInput): Promise<IBusiness> {
  const validated = validateInput(
    BusinessNewOperationInputSchema,
    input,
    "BusinessNewOperationInput"
  );
  // ... use validated
}
```

### Step 5: Update Operations (if needed)

```graphql
# src/graphql/operations/mutations.graphql
mutation NewBusinessOperation($input: BusinessNewOperationInput!) {
  newBusinessOperation(input: $input) {
    id
    name
  }
}
```

## Common Patterns

### Scalar Fields Pattern

```typescript
// Input type
export interface EntityScalarFields {
  name: string;
  description?: string;
}

// Schema
export const EntityScalarFieldsSchema = z.object({
  name: z.string().min(1).max(200),
  description: z.string().max(5000).optional(),
});
```

### Create with Relations Pattern

```typescript
// Input type
export interface EntityCreateWithOptionalIdsInput extends EntityScalarFields {
  relationIds?: string[];
}

// Schema
export const EntityCreateWithOptionalIdsInputSchema =
  EntityScalarFieldsSchema.extend({
    relationIds: ObjectIdArraySchema.optional(),
  });
```

### Update Pattern

```typescript
// Input type
export interface EntityUpdateWithOptionalIdsInput {
  id: string;
  name?: string;
  relationIds?: string[];
}

// Schema
export const EntityUpdateWithOptionalIdsInputSchema =
  EntityScalarFieldsSchema.partial().extend({
    id: ObjectIdSchema,
    relationIds: ObjectIdArraySchema.optional(),
  });
```

### Nested Input Pattern

```typescript
// Input type
export interface EntityRelationNestedInput {
  id?: string;
  name?: string;
  // ... other fields
}

// Schema with refinement
export const EntityRelationNestedInputSchema = z
  .object({
    id: ObjectIdSchema.optional(),
    name: z.string().min(1).max(200).optional(),
  })
  .refine((data) => data.id || data.name, {
    message: "Either 'id' or 'name' must be provided",
    path: ["name"],
  });
```

## Rules Summary

### ✅ CORRECT Patterns

```typescript
// Import input types and schemas
import { BusinessCreateInput } from "../graphql/inputs/businessInputs.js";
import { BusinessCreateSchema } from "../graphql/inputs/schemas/businessSchemas.js";

// Validate in service
const validated = validateInput(
  BusinessCreateSchema,
  input,
  "BusinessCreateInput"
);

// Use shared validators
import {
  ObjectIdSchema,
  ObjectIdArraySchema,
  OptionalUrlSchema,
} from "../lib/validation.js";

// Match schema to input type structure
const Schema = InputTypeSchema.partial().extend({ id: ObjectIdSchema });
```

### ❌ INCORRECT Patterns

```typescript
// ❌ Don't skip validation
async createBusiness(input: BusinessCreateInput) {
  return await Business.create(input); // No validation!
}

// ❌ Don't create schemas that don't match input types
const Schema = z.object({
  name: z.string(),
  // Missing fields from input type
});

// ❌ Don't use raw Zod without shared validators
const idSchema = z.string().regex(/^[0-9a-f]{24}$/); // Use ObjectIdSchema instead

// ❌ Don't forget to add to GraphQL schema
// Input type exists but not in schema.graphql
```

## Reference Files

- @src/lib/validation.ts - Validation function and shared validators
- @src/graphql/inputs/episodeInputs.ts - Input type examples
- @src/graphql/inputs/schemas/episodeSchemas.ts - Zod schema examples
- @src/graphql/operations/ - GraphQL operations for SDK generation
- @src/graphql/schema.graphql - GraphQL schema (large file, reference when needed)
