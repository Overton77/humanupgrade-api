---
description: "DataLoader patterns for preventing N+1 queries. Use loaders from ctx.loaders in resolvers to batch and cache entity fetches. Loaders are created per request in GraphQL context."
globs:
  - "src/graphql/resolvers/**/*.ts"
  - "src/graphql/loaders/**/*.ts"
  - "src/graphql/context.ts"
alwaysApply: false
---

# DataLoader Pattern

DataLoaders solve the **N+1 query problem** by batching and caching database queries. Instead of making one query per entity, loaders batch multiple requests into a single query.

**Example**: Querying `{ businesses { products { name } } }` without loaders would execute 1 + N queries (one per business). With loaders, it executes just 2 queries total.

## Loader Architecture

Loaders are created **per request** in the GraphQL context and attached to `ctx.loaders`:

```typescript
export interface GraphQLContext {
  userId: string | null;
  role: Role | null;
  loaders: {
    userById: DataLoader<string, IUser | null>;
    savedTargets: SavedTargetLoaders;
    entities: EntityLoaders;
  };
  requestId?: string;
}
```

**Reference**: @src/graphql/context.ts

## Loader Types

Three loader groups are available in `ctx.loaders`:

1. **`userById`** - Loads users by ID (used in resolvers and auth helpers)
2. **`entities`** - Loads core entities (Product, Business, Person, etc.) by ID
3. **`savedTargets`** - Loads entities for UserSaved union types

**Reference**: @src/graphql/context.ts, @src/graphql/loaders/entityLoaders.ts, @src/graphql/loaders/savedTargetLoaders.ts

## Creating Loaders

Loaders use `batchByIds` helper which:

1. Executes single `find({ _id: { $in: ids } })` query
2. Creates Map for O(1) lookup
3. Returns array matching input order (null for missing)

For reverse lookups (one-to-many), find all docs then group by foreign key.

**Reference**: @src/graphql/loaders/utils.ts, @src/graphql/loaders/entityLoaders.ts

## Using Loaders in Resolvers

Always use loaders in **type resolvers** (field resolvers) for related entities:

```typescript
// ✅ CORRECT: Use loader
Business: {
  products: (parent, _args, ctx) =>
    ctx.loaders.entities.productById.loadMany(parent.productIds ?? []),
}

// ❌ INCORRECT: Direct query (causes N+1)
Business: {
  products: async (parent) =>
    await Product.find({ businessId: parent._id }), // N+1 problem!
}
```

**Methods**:

- `.load(id)` - Single entity, returns `Entity | null`
- `.loadMany(ids)` - Multiple entities, returns `(Entity | Error | null)[]`

**Always filter errors/null**:

```typescript
const valid = results.filter(
  (r): r is HydratedDocument<IEntity> => r !== null && !(r instanceof Error)
);
```

**Reference**: @src/graphql/resolvers/index.ts

## Loader Creation

Loaders are created **per request** in `createContext()`. Each request gets fresh loader instances with per-request caching (cleared after request completes).

**Reference**: @src/graphql/context.ts

## Rules

### ✅ CORRECT

```typescript
// Use loaders in type resolvers
Business: {
  products: (parent, _args, ctx) =>
    ctx.loaders.entities.productById.loadMany(parent.productIds ?? []),
}

// Filter errors/null
const valid = results.filter(
  (r): r is HydratedDocument<IEntity> =>
    r !== null && !(r instanceof Error)
);
```

### ❌ INCORRECT

```typescript
// ❌ Don't query models directly (N+1 problem)
Business: {
  products: async (parent) => await Product.find({ businessId: parent._id }),
}

// ❌ Don't use services in type resolvers
Product: {
  business: async (parent, _args, ctx) =>
    await businessService.findById(parent.businessId), // Wrong layer!
}
```

## When to Use Loaders

**✅ Use loaders for**: Type resolvers (field resolvers), nested queries, union types

**❌ Don't use loaders for**: Query/Mutation resolvers (use services), complex queries, aggregations

**Example**:

```typescript
// Query resolver - use service
export const Query = {
  business: async (_parent, args) =>
    await businessService.findById(args.id), // ✅ Service
};

// Type resolver - use loader
Business: {
  products: (parent, _args, ctx) =>
    ctx.loaders.entities.productById.loadMany(parent.productIds ?? []), // ✅ Loader
}
```

## Adding New Loaders

1. Add to loader interface in `entityLoaders.ts`
2. Create loader using `batchByIds()` helper
3. Use in type resolvers via `ctx.loaders.entities.newEntityById`

**Reference**: @src/graphql/loaders/utils.ts, @src/graphql/loaders/entityLoaders.ts

## Reference Files

- @src/graphql/context.ts - Context and loader setup
- @src/graphql/loaders/entityLoaders.ts - Entity loaders
- @src/graphql/loaders/savedTargetLoaders.ts - Saved target loaders
- @src/graphql/loaders/utils.ts - Loader utilities
- @src/graphql/resolvers/index.ts - Type resolver examples
