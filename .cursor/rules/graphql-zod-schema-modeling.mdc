---
description: This rule is helpful for modeling neo4j knowledge graph in graphql  and zod for both the model types and the CRUD related to the models
alwaysApply: false
---

# GraphQL & Zod Schema Modeling Pattern

## Overview

This project models Neo4j knowledge graph entities using a consistent pattern: **Edge Types** that combine relationship properties with related nodes. This enables type-safe GraphQL APIs with clear relationship semantics.

## Pattern Structure

**NOTE:** We will sometimes use one major **Upsert** pattern for a model and only use `connect` + `create` (where `create` has upsert-like semantics in the service layer) for relationship types.

### Modeling patterns evolve

These patterns are a **living standard**. As the codebase and ingestion workloads develop, we may revise patterns (e.g., consolidate mutations, switch edge operations to upsert-by-key, add batch upserts) to improve **developer velocity**, **ingestion efficiency**, and **data integrity**. When patterns change, update both GraphQL schema and Zod inputs together.

### 1. GraphQL Schema

Define types and edge types in GraphQL schema:

```graphql
type Organization {
  organizationId: ID!
  name: String!
  # Relationships as edge types
  offersProduct: [OffersProductEdge!]
  hasLocation: [HasLocationEdge!]
}

type OffersProductEdge {
  product: Product!
  # Relationship properties + temporal validity
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasLocationEdge {
  location: PhysicalLocation!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

**Key Points:**
- Relationships are modeled as edge types, not direct node arrays
- Edge types contain: related node + relationship properties + temporal validity
- Expose high-quality relationships for LLM assistants and search
- Relationship direction: primarily outgoing (e.g., Organization.offersProduct), rarely incoming

### 2. Zod Model Schema (types/*Model.ts)

Create Zod schemas that match the GraphQL output shape (not raw Neo4j structure):

// Reference: src/graphql/types/OrganizationModel.ts

// Base node schema
export const ProductSchema = z.object({
  productId: z.string(),
  name: z.string(),
  productDomain: ProductDomainEnum,
  // ... other properties
});

// Edge type schema (relationship + node)
export const OffersProductEdgeSchema = TemporalValiditySchema.extend({
  product: ProductSchema, // Related node
  // Relationship properties included here
});

// Main model schema
export const OrganizationSchema = z.object({
  organizationId: z.string(),
  name: z.string(),
  // Relationships as arrays of edge types
  offersProduct: z.array(OffersProductEdgeSchema).nullable(),
  hasLocation: z.array(HasLocationEdgeSchema).nullable(),
});

// Infer TypeScript type
export type Organization = z.infer<typeof OrganizationSchema>;

**Key Points:**
- Model schemas represent the GraphQL output shape
- Edge types extend TemporalValiditySchema (validAt, invalidAt, expiredAt, createdAt)
- Use z.array(EdgeSchema).nullable() for relationship arrays
- Always infer TypeScript types: z.infer<typeof Schema>

### 2.5 Neo4j Property Constraints

CRITICAL: Maps/Objects as Neo4j Properties are NOT Allowed

Neo4j node and relationship properties must be primitive types or arrays of primitives. Objects/maps as property values are not supported.

❌ FORBIDDEN:

// DO NOT use maps/objects as properties
export const BadSchema = z.object({
  employeeCount: z
    .object({
      min: z.number().int().nullable(),
      max: z.number().int().nullable(),
    })
    .nullable(), // ❌ NOT ALLOWED
});

✅ CORRECT Approaches:

Option 1: Branch to Multiple Primitive Properties (Recommended for ranges/pairs)

// Use separate properties for min/max
export const OrganizationSchema = z.object({
  organizationId: z.string(),
  name: z.string(),
  employeeCountMin: z.number().int().nullable(), // ✅ Separate property
  employeeCountMax: z.number().int().nullable(), // ✅ Separate property
  revenueAnnualMin: z.number().nullable(), // ✅ Separate property
  revenueAnnualMax: z.number().nullable(), // ✅ Separate property
  valuationMin: z.number().nullable(), // ✅ Separate property
  valuationMax: z.number().nullable(), // ✅ Separate property
});

Option 2: Use Arrays of Primitives (For lists/sets)

// Use arrays for collections
export const OrganizationSchema = z.object({
  organizationId: z.string(),
  aliases: z.array(z.string()).nullable(), // ✅ Array of strings
  primaryIndustryTags: z.array(z.string()).nullable(), // ✅ Array of strings
  regionsServed: z.array(z.string()).nullable(), // ✅ Array of strings
  claimIds: z.array(z.string()), // ✅ Array of strings
});

**Allowed Property Types:**
- Primitives: string, number, boolean, null
- Arrays of primitives: z.array(z.string()), z.array(z.number())
- Enums (treated as strings): OrgTypeEnum, BusinessModelEnum
- Date strings: Neo4jDateString, Neo4jDateTimeString

**Reference Examples:**
- `src/graphql/types/OrganizationModel.ts` — Shows employeeCountMin/employeeCountMax pattern
- `src/graphql/inputs/OrganizationInputs.ts` — Input schemas with separated properties

### 3. Zod Input Schemas (inputs/*Inputs.ts)

Create input schemas with nested create/connect/update support:

// Reference: src/graphql/inputs/OrganizationInputs.ts

// Base node input (for creates)
export const ProductInputSchema = z.object({
  productId: z.string().optional(), // Auto-generated if not provided
  name: z.string(),
  productDomain: ProductDomainEnum,
  // ... other properties (all optional for nullable fields)
});

// Update input (all fields optional)
export const ProductUpdateInputSchema = ProductInputSchema.partial().extend({
  productId: z.string().optional(),
});

// Relationship input with create/connect
export const ProductRelateInputSchema = z
  .object({
    create: ProductInputSchema.optional(),
    connect: z.object({ productId: z.string() }).optional(),
  })
  .refine((data) => (data.create ? 1 : 0) + (data.connect ? 1 : 0) === 1, {
    message: "Exactly one of 'create' or 'connect' must be provided",
  });

// Relationship input with create/connect/update (for updates)
export const ProductRelateUpdateInputSchema = z
  .object({
    create: ProductInputSchema.optional(),
    connect: z.object({ productId: z.string() }).optional(),
    update: ProductUpdateInputSchema.optional(),
  })
  .refine(
    (data) =>
      (data.create ? 1 : 0) + (data.connect ? 1 : 0) + (data.update ? 1 : 0) ===
      1,
    {
      message:
        "Exactly one of 'create', 'connect', or 'update' must be provided",
    }
  );

// Relationship input schema (for creates)
export const OffersProductRelationshipInputSchema =
  TemporalValidityInputSchema.extend({
    product: ProductRelateInputSchema, // create OR connect
    // Relationship properties
  });

// Relationship update input schema (for updates)
export const OffersProductRelationshipUpdateInputSchema =
  TemporalValidityInputSchema.extend({
    product: ProductRelateUpdateInputSchema, // create OR connect OR update
    // Relationship properties (all optional)
  });

// Main input schema
export const OrganizationInputSchema = z.object({
  organizationId: z.string().optional(),
  name: z.string(),
  // Relationships
  offersProduct: z.array(OffersProductRelationshipInputSchema).optional(),
  hasLocation: z.array(HasLocationRelationshipInputSchema).optional(),
});

// Update input (all fields optional, uses update relationship schemas)
export const UpdateOrganizationInputSchema = z.object({
  organizationId: z.string().optional(),
  name: z.string().optional(),
  offersProduct: z.array(OffersProductRelationshipUpdateInputSchema).optional(),
  // ... other fields optional
});

**Key Points:**
- Create inputs: Use *RelateInputSchema (create OR connect)
- Update inputs: Use *RelateUpdateInputSchema (create OR connect OR update)
- Use .refine() to ensure exactly one option is provided
- Relationship inputs extend TemporalValidityInputSchema (all optional)
- Update inputs: all fields optional, use update relationship schemas

### 3.5 Upsert + ConnectByKey Edge Pattern (Media + Ingestion-First)

For ingestion-heavy domains (e.g., Media), relationship inputs may use a simplified Upsert edge pattern. In these models, edge inputs only allow:

connect (by ID)

connectByKey (by natural key)

upsert (create-or-update)

This replaces nested create/connect/update variants and keeps input sizes small while enabling one-pass ingestion.

input RelateUpsertInput {
  connect: ConnectByIdInput
  connectByKey: ConnectByKeyInput
  upsert: ModelRelateUpsertInput
}

Example (media speaker attribution):

input ClaimOccurrenceUpsertInput {
  canonicalText: String!
  occursIn: EpisodeRelateUpsertInput!
  occursInSegment: EpisodeSegmentRelateUpsertInput
  utteredBy: PersonRelateInput! # supports connect or upsert
}

**Resolver semantics:**
- upsert<Model> merges by id or connectByKey natural keys
- edge application is additive: connect if missing; update relationship properties if provided
- list edges that are refreshed by ingestion may optionally support mode = PATCH | REPLACE_ALL (e.g., episode segments)

### 4. Temporal Validity Pattern

All relationships support temporal validity:

// Model schema (output)
export const TemporalValiditySchema = z.object({
  validAt: Neo4jDateTimeString,
  invalidAt: Neo4jDateTimeString,
  expiredAt: Neo4jDateTimeString,
  createdAt: Neo4jDateTimeString,
});

// Input schema (all optional)
export const TemporalValidityInputSchema = z.object({
  validAt: Neo4jDateTimeString.optional(),
  invalidAt: Neo4jDateTimeString.optional(),
  expiredAt: Neo4jDateTimeString.optional(),
  createdAt: Neo4jDateTimeString.optional(),
});

**Date/DateTime Types:**
- Use Neo4jDateString for DATE-only fields (YYYY-MM-DD)
- Use Neo4jDateTimeString for DATETIME fields (ISO 8601)

**Reference:** `src/graphql/utils/dateTimeUtils.ts`

## Implementation Checklist

When adding a new entity:

✅ Define GraphQL types in the schema modules (see Schema Reference below)

✅ Create base node Zod schemas in types/*Model.ts

✅ Create edge type Zod schemas (extend TemporalValiditySchema)

✅ Create input Zod schemas in inputs/*Inputs.ts

- Base input schema
- Update input schema (.partial())
- Relate input schema (create/connect)
- Relate update input schema (create/connect/update)
- Relationship input schemas
- Main input and update input schemas

✅ Infer TypeScript types from Zod schemas

✅ Implement service layer (see neo4j-create-update-patterns.mdc)

✅ Add DataLoaders (see dataloader-pattern.mdc)

## Schema & Code Reference

### Modularized GraphQL Schema

The GraphQL schema is modularized in **`src/graphql/modules/`**. Each domain module uses `00-types.graphql`, `01-edges.graphql`, `02-inputs.graphql`, and `03-operations.graphql`. A full built schema exists at `src/graphql/schema.graphql` (generated from the module files—see [build-schema.ts](mdc:api/scripts/build-schema.ts) and [codebase-organization.mdc](mdc:api/.cursor/codebase-organization.mdc)).

### Implementation Examples

- **Model Schema:** `src/graphql/types/OrganizationModel.ts`
- **Input Schema:** `src/graphql/inputs/OrganizationInputs.ts`
