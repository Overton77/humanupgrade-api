import { promises as fs } from "node:fs";
import { watch } from "node:fs";
import path from "node:path";
import process from "node:process";

import { buildASTSchema, parse } from "graphql";

type FileEntry = {
  absPath: string;
  relPath: string;
};

const GRAPHQL_EXT = ".graphql";

function isGraphqlFile(p: string): boolean {
  return p.toLowerCase().endsWith(GRAPHQL_EXT);
}

async function listGraphqlFilesRec(dirAbs: string, rootAbs: string): Promise<FileEntry[]> {
  const out: FileEntry[] = [];
  const entries = await fs.readdir(dirAbs, { withFileTypes: true });

  // Stable ordering within a directory so output doesn't churn.
  entries.sort((a, b) => a.name.localeCompare(b.name));

  for (const ent of entries) {
    const abs = path.join(dirAbs, ent.name);
    if (ent.isDirectory()) {
      out.push(...(await listGraphqlFilesRec(abs, rootAbs)));
    } else if (ent.isFile() && isGraphqlFile(ent.name)) {
      out.push({ absPath: abs, relPath: path.relative(rootAbs, abs) });
    }
  }

  return out;
}

function moduleOrderKey(relPathFromModules: string): string {
  // relPathFromModules looks like: "_shared/00-scalars.graphql" or "organization/02-inputs.graphql"
  const segs = relPathFromModules.split(/[\\/]/g);
  const top = segs[0] ?? "";

  // Force deterministic ordering across modules.
  // 1) _shared
  // 2) roots
  // 3) everything else alphabetically
  const moduleRank =
    top === "_shared" ? "00" :
    top === "roots" ? "01" :
    `10-${top}`;

  // Within module, rely on numeric prefixes (00-, 01-, etc.) and filename ordering.
  return `${moduleRank}/${segs.slice(1).join("/")}`;
}

function normalizeNewlines(s: string): string {
  // Keep output consistent across OS.
  return s.replace(/\r\n/g, "\n");
}

function ensureEndsWithNewline(s: string): string {
  return s.endsWith("\n") ? s : s + "\n";
}

async function main(): Promise<void> {
  const projectRoot = process.cwd(); // run from /api
  const modulesDir = path.join(projectRoot, "src", "graphql", "modules");
  const outputPath = path.join(projectRoot, "src", "graphql", "schema.graphql");

  // Discover all .graphql files under modules/
  const files = await listGraphqlFilesRec(modulesDir, modulesDir);
  if (files.length === 0) {
    throw new Error(`No ${GRAPHQL_EXT} files found under ${modulesDir}`);
  }

  // Sort files in the exact concatenation order we want.
  files.sort((a, b) => moduleOrderKey(a.relPath).localeCompare(moduleOrderKey(b.relPath)));

  // Read all files concurrently (smart concurrency).
  const contents = await Promise.all(
    files.map(async (f) => {
      const raw = await fs.readFile(f.absPath, "utf8");
      const text = ensureEndsWithNewline(normalizeNewlines(raw)).trimEnd() + "\n";
      return { ...f, text };
    })
  );

  const header =
    "# ------------------------------------------------------------------------------\n" +
    "# AUTO-GENERATED FILE ‚Äî DO NOT EDIT DIRECTLY\n" +
    "#\n" +
    "# Source: src/graphql/modules/**\n" +
    "# Generated by: scripts/build-schema.ts\n" +
    "# ------------------------------------------------------------------------------\n\n";

  const body = contents
    .map((f) => {
      return (
        `# ===== BEGIN: ${f.relPath.replace(/\\/g, "/")} =====\n` +
        f.text +
        `# ===== END: ${f.relPath.replace(/\\/g, "/")} =====\n\n`
      );
    })
    .join("");

  const combined = header + body;

  // Validate the SDL early so server start/build fails fast.
  // - parse() checks syntax
  // - buildASTSchema() checks type system validity (e.g., bad extends, duplicate types)
  const doc = parse(combined);
  buildASTSchema(doc);

  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, combined, "utf8");

  console.log(`‚úÖ Wrote combined schema to ${path.relative(projectRoot, outputPath)}`);
  console.log(`   Included ${contents.length} files from src/graphql/modules/`);
}

async function watchMode(): Promise<void> {
  const projectRoot = process.cwd();
  const modulesDir = path.join(projectRoot, "src", "graphql", "modules");
  
  console.log(`üëÄ Watching ${modulesDir} for changes...`);
  console.log("   Press Ctrl+C to stop\n");

  // Initial build
  await main().catch((err) => {
    console.error("‚ùå Failed to build schema:");
    console.error(err);
  });

  // Watch for changes
  watch(modulesDir, { recursive: true }, async (eventType, filename) => {
    if (filename && filename.endsWith(".graphql")) {
      console.log(`\nüìù Detected change: ${filename}`);
      try {
        await main();
      } catch (err: any) {
        console.error("‚ùå Failed to rebuild schema:");
        console.error(err?.message || err);
      }
    }
  });
}

if (process.argv.includes("--watch") || process.argv.includes("-w")) {
  watchMode().catch((err) => {
    console.error("‚ùå Watch mode failed:");
    console.error(err);
    process.exit(1);
  });
} else {
  main().catch((err) => {
    console.error("‚ùå Failed to build schema:");
    console.error(err);
    process.exit(1);
  });
}