scalar DateTime
scalar JSON

# ============================================================================
# Enums
# ============================================================================

enum OrgType {
  COMPANY
  NONPROFIT
  RESEARCH_GROUP
  COMMUNITY
  MEDIA_OUTLET
  CLINIC
  FOUNDATION
  REGULATOR
  JOURNAL
  LAB_NETWORK
  DISTRIBUTOR
  MANUFACTURER
  SUPPLIER
  PLATFORM
  OTHER
}

enum BusinessModel {
  B2C
  B2B
  B2B2C
  HYBRID
  UNKNOWN
}

enum LocationType {
  HEADQUARTERS
  REGISTERED_ADDRESS
  OFFICE
  LAB_FACILITY
  CLINIC_SITE
  MANUFACTURING_SITE
  WAREHOUSE
  RETAIL_SITE
  DATA_CENTER
  RESEARCH_SITE
  COLLECTION_SITE
  CONFERENCE_VENUE
  OTHER
}

enum ListingDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum PriceType {
  LIST
  PROMO
  MEMBER_ONLY
  INSURANCE_ESTIMATE
  UNKNOWN
}

enum CollectionMode {
  AT_HOME_KIT
  IN_PERSON_DRAW
  MOBILE_PHLEBOTOMY
  IN_CLINIC
  SHIPPING
  TELEHEALTH
  VIRTUAL
  OTHER
}

enum ProductDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum ListRole {
  OPERATOR
  PROVIDER
  SELLER
  DISTRIBUTOR
  MARKETER
  FULFILLMENT_PARTNER
  BILLING_ENTITY
  OTHER
}

enum Channel {
  ONLINE
  IN_PERSON
  PHONE
  PARTNER
  MARKETPLACE
  OTHER
}

enum ProcessType {
  chemical_synthesis
  fermentation
  extraction
  semi_synthesis
  formulation
  assembly
  packaging
  qc_release
  other
}

enum ScalabilityLevel {
  lab
  pilot
  commercial
  unknown
}

enum PlatformType {
  THERAPEUTIC_PLATFORM
  DIAGNOSTIC_PLATFORM
  MANUFACTURING_PLATFORM
  MODALITY_PLATFORM
  ANALYTICS_PLATFORM
  OTHER
}

enum RelationshipRole {
  PRIMARY_DEVELOPER
  CO_DEVELOPER
  MAINTAINER
  STEWARD
  UNKNOWN
}

enum UsageContext {
  R_AND_D
  PRODUCTION
  QC
  CLINICAL
  ANALYTICS
  OTHER
  UNKNOWN
}

enum Source {
  CURATED
  IMPORTED
  DERIVED
}

enum ManufacturingRole {
  primary
  subcontractor
  cdmo
  cmo
  api_supplier
  other
}

# ============================================================================
# Base Node Types
# ============================================================================

type PhysicalLocation {
  locationId: ID!
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

type Listing {
  listingId: ID!
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

type Product {
  productId: ID!
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
}

type CompoundForm {
  compoundFormId: ID!
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

type ManufacturingProcess {
  manufacturingProcessId: ID!
  canonicalName: String!
  processType: ProcessType!
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type TechnologyPlatform {
  platformId: ID!
  canonicalName: String!
  aliases: [String!]
  platformType: PlatformType!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# ============================================================================
# Edge Types (Relationships with Properties)
# ============================================================================

type HasLocationEdge {
  location: PhysicalLocation!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OwnsOrControlsEdge {
  organization: Organization!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ListsEdge {
  listing: Listing!
  listRole: ListRole!
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OffersProductEdge {
  product: Product!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type SuppliesCompoundFormEdge {
  compoundForm: CompoundForm!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturesEdge {
  compoundForm: CompoundForm!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturesProductEdge {
  product: Product!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForOrganizationEdge {
  organization: Organization!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForProductEdge {
  product: Product!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForCompoundFormEdge {
  compoundForm: CompoundForm!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type PerformsManufacturingProcessEdge {
  manufacturingProcess: ManufacturingProcess!
  role: ManufacturingRole!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DevelopsPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type UsesPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# ============================================================================
# Organization Type
# ============================================================================

type Organization {
  organizationId: ID!
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  # Relationships
  hasLocation: [HasLocationEdge!]
  ownsOrControls: [OwnsOrControlsEdge!]
  lists: [ListsEdge!]
  offersProduct: [OffersProductEdge!]
  suppliesCompoundForm: [SuppliesCompoundFormEdge!]
  manufactures: [ManufacturesEdge!]
  manufacturesProduct: [ManufacturesProductEdge!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationEdge!]
  contractManufacturerForProduct: [ContractManufacturerForProductEdge!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormEdge!]
  performsManufacturingProcess: [PerformsManufacturingProcessEdge!]
  developsPlatform: [DevelopsPlatformEdge!]
  usesPlatform: [UsesPlatformEdge!]
}

# ============================================================================
# Input Types
# ============================================================================

input TemporalValidityInput {
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PhysicalLocationInput {
  locationId: ID
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

input ListingInput {
  listingId: ID
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

input ProductInput {
  productId: ID
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
}

input CompoundFormInput {
  compoundFormId: ID
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

# ============================================================================
# Update Input Types (all fields optional for partial updates)
# ============================================================================

input PhysicalLocationUpdateInput {
  locationId: ID
  canonicalName: String
  locationType: LocationType
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

input ListingUpdateInput {
  listingId: ID
  listingDomain: ListingDomain
  title: String
  description: String
  sku: String
  url: String
  brandName: String
  currency: String
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

input ProductUpdateInput {
  productId: ID
  name: String
  synonyms: [String!]
  productDomain: ProductDomain
  productType: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
}

input CompoundFormUpdateInput {
  compoundFormId: ID
  canonicalName: String
  formType: String
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

input ManufacturingProcessInput {
  manufacturingProcessId: ID
  canonicalName: String!
  processType: ProcessType!
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturingProcessUpdateInput {
  manufacturingProcessId: ID
  canonicalName: String
  processType: ProcessType
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input TechnologyPlatformInput {
  platformId: ID
  canonicalName: String!
  aliases: [String!]
  platformType: PlatformType!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input TechnologyPlatformUpdateInput {
  platformId: ID
  canonicalName: String
  aliases: [String!]
  platformType: PlatformType
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# Relationship Inputs with nested create/connect/update
# Note: GraphQL doesn't support union types for inputs, so we use optional fields
# Resolvers should validate that exactly one of create/connect is provided

input PhysicalLocationRelateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
}

input PhysicalLocationRelateUpdateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
  update: PhysicalLocationUpdateInput
}

input PhysicalLocationConnectInput {
  locationId: ID!
}

input HasLocationRelationshipInput {
  location: PhysicalLocationRelateInput!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasLocationRelationshipUpdateInput {
  location: PhysicalLocationRelateUpdateInput!
  locationRole: String
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OrganizationRelateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
}

input OrganizationRelateUpdateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
  update: UpdateOrganizationInput
}

input OrganizationConnectInput {
  organizationId: ID!
}

input OwnsOrControlsRelationshipInput {
  organization: OrganizationRelateInput!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OwnsOrControlsRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  relationshipType: String
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ListingRelateInput {
  create: ListingInput
  connect: ListingConnectInput
}

input ListingRelateUpdateInput {
  create: ListingInput
  connect: ListingConnectInput
  update: ListingUpdateInput
}

input ListingConnectInput {
  listingId: ID!
}

input ListsRelationshipInput {
  listing: ListingRelateInput!
  listRole: ListRole!
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ListsRelationshipUpdateInput {
  listing: ListingRelateUpdateInput!
  listRole: ListRole
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductRelateInput {
  create: ProductInput
  connect: ProductConnectInput
}

input ProductRelateUpdateInput {
  create: ProductInput
  connect: ProductConnectInput
  update: ProductUpdateInput
}

input ProductConnectInput {
  productId: ID!
}

input OffersProductRelationshipInput {
  product: ProductRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OffersProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input CompoundFormRelateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
}

input CompoundFormRelateUpdateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
  update: CompoundFormUpdateInput
}

input CompoundFormConnectInput {
  compoundFormId: ID!
}

input SuppliesCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SuppliesCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturingProcessRelateInput {
  create: ManufacturingProcessInput
  connect: ManufacturingProcessConnectInput
}

input ManufacturingProcessRelateUpdateInput {
  create: ManufacturingProcessInput
  connect: ManufacturingProcessConnectInput
  update: ManufacturingProcessUpdateInput
}

input ManufacturingProcessConnectInput {
  manufacturingProcessId: ID!
}

input TechnologyPlatformRelateInput {
  create: TechnologyPlatformInput
  connect: TechnologyPlatformConnectInput
}

input TechnologyPlatformRelateUpdateInput {
  create: TechnologyPlatformInput
  connect: TechnologyPlatformConnectInput
  update: TechnologyPlatformUpdateInput
}

input TechnologyPlatformConnectInput {
  platformId: ID!
}

input ManufacturesRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesProductRelationshipInput {
  product: ProductRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForOrganizationRelationshipInput {
  organization: OrganizationRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForOrganizationRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForProductRelationshipInput {
  product: ProductRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PerformsManufacturingProcessRelationshipInput {
  manufacturingProcess: ManufacturingProcessRelateInput!
  role: ManufacturingRole!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PerformsManufacturingProcessRelationshipUpdateInput {
  manufacturingProcess: ManufacturingProcessRelateUpdateInput!
  role: ManufacturingRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DevelopsPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DevelopsPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OrganizationInput {
  organizationId: ID
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  # Relationships
  hasLocation: [HasLocationRelationshipInput!]
  ownsOrControls: [OwnsOrControlsRelationshipInput!]
  lists: [ListsRelationshipInput!]
  offersProduct: [OffersProductRelationshipInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipInput!]
  manufactures: [ManufacturesRelationshipInput!]
  manufacturesProduct: [ManufacturesProductRelationshipInput!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationRelationshipInput!]
  contractManufacturerForProduct: [ContractManufacturerForProductRelationshipInput!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormRelationshipInput!]
  performsManufacturingProcess: [PerformsManufacturingProcessRelationshipInput!]
  developsPlatform: [DevelopsPlatformRelationshipInput!]
  usesPlatform: [UsesPlatformRelationshipInput!]
}

input UpdateOrganizationInput {
  organizationId: ID
  name: String
  aliases: [String!]
  orgType: OrgType
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  # Relationships (using update versions)
  hasLocation: [HasLocationRelationshipUpdateInput!]
  ownsOrControls: [OwnsOrControlsRelationshipUpdateInput!]
  lists: [ListsRelationshipUpdateInput!]
  offersProduct: [OffersProductRelationshipUpdateInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipUpdateInput!]
  manufactures: [ManufacturesRelationshipUpdateInput!]
  manufacturesProduct: [ManufacturesProductRelationshipUpdateInput!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationRelationshipUpdateInput!]
  contractManufacturerForProduct: [ContractManufacturerForProductRelationshipUpdateInput!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormRelationshipUpdateInput!]
  performsManufacturingProcess: [PerformsManufacturingProcessRelationshipUpdateInput!]
  developsPlatform: [DevelopsPlatformRelationshipUpdateInput!]
  usesPlatform: [UsesPlatformRelationshipUpdateInput!]
}

# ============================================================================
# Query & Mutation
# ============================================================================

type Query {
  organizations: [Organization!]!
}

type Mutation {
  createOrganization(input: OrganizationInput!): Organization!
  updateOrganization(input: UpdateOrganizationInput!): Organization!
}
