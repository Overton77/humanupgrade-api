scalar DateTime
scalar JSON

# ============================================================================
# Enums
# ============================================================================

enum OrgType {
  COMPANY
  NONPROFIT
  RESEARCH_GROUP
  COMMUNITY
  MEDIA_OUTLET
  CLINIC
  FOUNDATION
  REGULATOR
  JOURNAL
  LAB_NETWORK
  DISTRIBUTOR
  MANUFACTURER
  SUPPLIER
  PLATFORM
  OTHER
}

enum BusinessModel {
  B2C
  B2B
  B2B2C
  HYBRID
  UNKNOWN
}

enum LocationType {
  HEADQUARTERS
  REGISTERED_ADDRESS
  OFFICE
  LAB_FACILITY
  CLINIC_SITE
  MANUFACTURING_SITE
  WAREHOUSE
  RETAIL_SITE
  DATA_CENTER
  RESEARCH_SITE
  COLLECTION_SITE
  CONFERENCE_VENUE
  OTHER
}

enum ListingDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum PriceType {
  LIST
  PROMO
  MEMBER_ONLY
  INSURANCE_ESTIMATE
  UNKNOWN
}

enum CollectionMode {
  AT_HOME_KIT
  IN_PERSON_DRAW
  MOBILE_PHLEBOTOMY
  IN_CLINIC
  SHIPPING
  VIRTUAL
  OTHER
}

enum ProductDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum ListRole {
  OPERATOR
  PROVIDER
  SELLER
  DISTRIBUTOR
  MARKETER
  FULFILLMENT_PARTNER
  BILLING_ENTITY
  OTHER
}

enum Channel {
  ONLINE
  IN_PERSON
  PHONE
  PARTNER
  MARKETPLACE
  OTHER
}

# ============================================================================
# Base Node Types
# ============================================================================

type PhysicalLocation {
  locationId: ID!
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geo: JSON
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contact: ContactMap
}

type ContactMap {
  phone: String
  email: String
}

type Listing {
  listingId: ID!
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

type Product {
  productId: ID!
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
}

type CompoundForm {
  compoundFormId: ID!
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

# ============================================================================
# Edge Types (Relationships with Properties)
# ============================================================================

type HasLocationEdge {
  location: PhysicalLocation!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OwnsOrControlsEdge {
  organization: Organization!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ListsEdge {
  listing: Listing!
  listRole: ListRole!
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OffersProductEdge {
  product: Product!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type SuppliesCompoundFormEdge {
  compoundForm: CompoundForm!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# ============================================================================
# Organization Type
# ============================================================================

type Organization {
  organizationId: ID!
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountRange: EmployeeCountRange
  revenueRangeAnnual: RevenueRangeAnnual
  valuationRange: ValuationRange
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  # Relationships
  hasLocation: [HasLocationEdge!]
  ownsOrControls: [OwnsOrControlsEdge!]
  lists: [ListsEdge!]
  offersProduct: [OffersProductEdge!]
  suppliesCompoundForm: [SuppliesCompoundFormEdge!]
}

type EmployeeCountRange {
  min: Int
  max: Int
  asOf: DateTime
}

type RevenueRangeAnnual {
  min: Float
  max: Float
  currency: String
  asOf: DateTime
}

type ValuationRange {
  min: Float
  max: Float
  currency: String
  asOf: DateTime
}

# ============================================================================
# Input Types
# ============================================================================

input ContactMapInput {
  phone: String
  email: String
}

input TemporalValidityInput {
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PhysicalLocationInput {
  locationId: ID
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geo: JSON
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contact: ContactMapInput
}

input ListingInput {
  listingId: ID
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

input ProductInput {
  productId: ID
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
}

input CompoundFormInput {
  compoundFormId: ID
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

# ============================================================================
# Update Input Types (all fields optional for partial updates)
# ============================================================================

input PhysicalLocationUpdateInput {
  locationId: ID
  canonicalName: String
  locationType: LocationType
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geo: JSON
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contact: ContactMapInput
}

input ListingUpdateInput {
  listingId: ID
  listingDomain: ListingDomain
  title: String
  description: String
  sku: String
  url: String
  brandName: String
  currency: String
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

input ProductUpdateInput {
  productId: ID
  name: String
  synonyms: [String!]
  productDomain: ProductDomain
  productType: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
}

input CompoundFormUpdateInput {
  compoundFormId: ID
  canonicalName: String
  formType: String
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

# Relationship Inputs with nested create/connect/update
# Note: GraphQL doesn't support union types for inputs, so we use optional fields
# Resolvers should validate that exactly one of create/connect is provided

input PhysicalLocationRelateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
}

input PhysicalLocationRelateUpdateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
  update: PhysicalLocationUpdateInput
}

input PhysicalLocationConnectInput {
  locationId: ID!
}

input HasLocationRelationshipInput {
  location: PhysicalLocationRelateInput!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasLocationRelationshipUpdateInput {
  location: PhysicalLocationRelateUpdateInput!
  locationRole: String
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OrganizationRelateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
}

input OrganizationRelateUpdateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
  update: UpdateOrganizationInput
}

input OrganizationConnectInput {
  organizationId: ID!
}

input OwnsOrControlsRelationshipInput {
  organization: OrganizationRelateInput!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OwnsOrControlsRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  relationshipType: String
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ListingRelateInput {
  create: ListingInput
  connect: ListingConnectInput
}

input ListingRelateUpdateInput {
  create: ListingInput
  connect: ListingConnectInput
  update: ListingUpdateInput
}

input ListingConnectInput {
  listingId: ID!
}

input ListsRelationshipInput {
  listing: ListingRelateInput!
  listRole: ListRole!
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ListsRelationshipUpdateInput {
  listing: ListingRelateUpdateInput!
  listRole: ListRole
  channel: Channel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductRelateInput {
  create: ProductInput
  connect: ProductConnectInput
}

input ProductRelateUpdateInput {
  create: ProductInput
  connect: ProductConnectInput
  update: ProductUpdateInput
}

input ProductConnectInput {
  productId: ID!
}

input OffersProductRelationshipInput {
  product: ProductRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OffersProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input CompoundFormRelateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
}

input CompoundFormRelateUpdateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
  update: CompoundFormUpdateInput
}

input CompoundFormConnectInput {
  compoundFormId: ID!
}

input SuppliesCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SuppliesCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input EmployeeCountRangeInput {
  min: Int
  max: Int
  asOf: DateTime
}

input RevenueRangeAnnualInput {
  min: Float
  max: Float
  currency: String
  asOf: DateTime
}

input ValuationRangeInput {
  min: Float
  max: Float
  currency: String
  asOf: DateTime
}

input OrganizationInput {
  organizationId: ID
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountRange: EmployeeCountRangeInput
  revenueRangeAnnual: RevenueRangeAnnualInput
  valuationRange: ValuationRangeInput
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  # Relationships
  hasLocation: [HasLocationRelationshipInput!]
  ownsOrControls: [OwnsOrControlsRelationshipInput!]
  lists: [ListsRelationshipInput!]
  offersProduct: [OffersProductRelationshipInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipInput!]
}

input UpdateOrganizationInput {
  organizationId: ID
  name: String
  aliases: [String!]
  orgType: OrgType
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountRange: EmployeeCountRangeInput
  revenueRangeAnnual: RevenueRangeAnnualInput
  valuationRange: ValuationRangeInput
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  # Relationships (using update versions)
  hasLocation: [HasLocationRelationshipUpdateInput!]
  ownsOrControls: [OwnsOrControlsRelationshipUpdateInput!]
  lists: [ListsRelationshipUpdateInput!]
  offersProduct: [OffersProductRelationshipUpdateInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipUpdateInput!]
}

# ============================================================================
# Query & Mutation
# ============================================================================

type Query {
  organizations: [Organization!]!
}

type Mutation {
  createOrganization(input: OrganizationInput!): Organization!
}
