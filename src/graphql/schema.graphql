# ------------------------------------------------------------------------------
# AUTO-GENERATED FILE — DO NOT EDIT DIRECTLY
#
# Source: src/graphql/modules/**
# Generated by: scripts/build-schema.ts
# ------------------------------------------------------------------------------

# ===== BEGIN: _shared/00-scalars.graphql =====
scalar DateTime
scalar JSON
# ===== END: _shared/00-scalars.graphql =====

# ===== BEGIN: _shared/01-enums.graphql =====
enum OrgType {
  COMPANY
  NONPROFIT
  RESEARCH_GROUP
  COMMUNITY
  MEDIA_OUTLET
  CLINIC
  FOUNDATION
  REGULATOR
  JOURNAL
  LAB_NETWORK
  DISTRIBUTOR
  MANUFACTURER
  SUPPLIER
  PLATFORM
  OTHER
}

enum BusinessModel {
  B2C
  B2B
  B2B2C
  HYBRID
  UNKNOWN
}

enum LocationType {
  HEADQUARTERS
  REGISTERED_ADDRESS
  OFFICE
  LAB_FACILITY
  CLINIC_SITE
  MANUFACTURING_SITE
  WAREHOUSE
  RETAIL_SITE
  DATA_CENTER
  RESEARCH_SITE
  COLLECTION_SITE
  CONFERENCE_VENUE
  OTHER
}

enum ListingDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum PriceType {
  LIST
  PROMO
  MEMBER_ONLY
  INSURANCE_ESTIMATE
  UNKNOWN
}

enum CollectionMode {
  AT_HOME_KIT
  IN_PERSON_DRAW
  MOBILE_PHLEBOTOMY
  IN_CLINIC
  SHIPPING
  TELEHEALTH
  VIRTUAL
  OTHER
}

enum ProductDomain {
  DIAGNOSTICS
  SUPPLEMENT
  DEVICE
  TELEHEALTH
  SOFTWARE
  SERVICE
  OTHER
}

enum ListRole {
  OPERATOR
  PROVIDER
  SELLER
  DISTRIBUTOR
  MARKETER
  FULFILLMENT_PARTNER
  BILLING_ENTITY
  OTHER
}

enum DistributionChannel {
  ONLINE
  IN_PERSON
  PHONE
  PARTNER
  MARKETPLACE
  OTHER
}

enum ProcessType {
  chemical_synthesis
  fermentation
  extraction
  semi_synthesis
  formulation
  assembly
  packaging
  qc_release
  other
}

enum ScalabilityLevel {
  lab
  pilot
  commercial
  unknown
}

enum PlatformType {
  THERAPEUTIC_PLATFORM
  DIAGNOSTIC_PLATFORM
  MANUFACTURING_PLATFORM
  MODALITY_PLATFORM
  ANALYTICS_PLATFORM
  OTHER
}

enum RelationshipRole {
  PRIMARY_DEVELOPER
  CO_DEVELOPER
  MAINTAINER
  STEWARD
  UNKNOWN
}

enum UsageContext {
  R_AND_D
  PRODUCTION
  QC
  CLINICAL
  ANALYTICS
  OTHER
  UNKNOWN
}

enum Source {
  CURATED
  IMPORTED
  DERIVED
}

enum ManufacturingRole {
  primary
  subcontractor
  cdmo
  cmo
  api_supplier
  other
}

enum LabTestRole {
  primary
  component
  reflex
  add_on
  eligibility_gate
}

enum PanelRole {
  primary
  variant
  legacy
}

enum CompoundFormRole {
  active
  excipient
  carrier
  other
}

enum BiomarkerRole {
  primary
  derived
  ratio
  composite
  other
}

enum MethodRole {
  primary
  confirmatory
  reflex
  backup
}

enum SpecimenRole {
  required
  acceptableAlternative
  preferred
}

enum CollectionSetting {
  AT_HOME
  CLINIC
  LAB
  MOBILE_PHLEBOTOMY
  HOSPITAL
  UNKNOWN
}

enum CollectionMethod {
  VENIPUNCTURE
  FINGERSTICK
  SALIVA_TUBE
  STOOL_KIT
  URINE_CUP
  SWAB
  OTHER
  UNKNOWN
}

enum CollectionTimeWindow {
  ANYTIME
  MORNING_ONLY
  TIMED_DRAW
  CYCLE_PHASED
  OTHER
  UNKNOWN
}

enum ProcessingAdditive {
  NONE
  EDTA
  HEPARIN
  CITRATE
  SST
  OTHER
  UNKNOWN
}

enum Sex {
  ANY
  FEMALE
  MALE
  INTERSEX
  UNKNOWN
}

enum MeasurementState {
  FASTING
  NON_FASTING
  POSTPRANDIAL
  RESTING
  EXERCISE
  SLEEP
  ACUTE_ILLNESS
  RECOVERY
  UNKNOWN
}

enum TimeOfDay {
  MORNING
  AFTERNOON
  EVENING
  NIGHT
  UNKNOWN
}

enum AppliesWhen {
  BASELINE
  CHANGE_FROM_BASELINE
  THRESHOLD_EXCEEDED
  TREND
  UNKNOWN
}

enum ThresholdDirection {
  ABOVE
  BELOW
  BOTH
  UNKNOWN
}

# ============================================================================
# Study / CaseStudy Enums
# ============================================================================

enum StudyKind {
  CASE_STUDY
  CASE_REPORT
  CASE_SERIES
  COHORT
  CROSS_SECTIONAL
  RCT
  OBSERVATIONAL
  SYSTEMATIC_REVIEW
  META_ANALYSIS
  OTHER
}

enum DesignKind {
  CASE_REPORT
  CASE_SERIES
  RETROSPECTIVE_COHORT
  PROSPECTIVE_COHORT
  CROSS_SECTIONAL
  PARALLEL_GROUP_RCT
  CROSSOVER_RCT
  FACTORIAL_RCT
  SINGLE_ARM_TRIAL
  DOSE_ESCALATION
  N_OF_1
  SYSTEMATIC_REVIEW
  META_ANALYSIS
  NARRATIVE_REVIEW
  OTHER
}

enum StudyStatus {
  PLANNED
  RECRUITING
  ACTIVE
  COMPLETED
  SUSPENDED
  TERMINATED
  WITHDRAWN
  UNKNOWN
}

enum BlindedKind {
  OPEN_LABEL
  SINGLE_BLIND
  DOUBLE_BLIND
  TRIPLE_BLIND
  UNKNOWN
}

enum ComparatorType {
  PLACEBO
  ACTIVE_CONTROL
  USUAL_CARE
  WAITLIST
  NO_TREATMENT
  DOSE_RESPONSE
  HISTORICAL
  OTHER
}

enum PopulationKind {
  HUMAN
  ANIMAL
  IN_VITRO
  IN_SILICO
  MIXED
  OTHER
}

enum DatasetKind {
  RAW
  CLEANED
  ANALYTIC
  SUMMARY
  BIOBANK
  REGISTRY
  CLAIMS
  EHR
  OTHER
}

enum DatasetAccessLevel {
  PUBLIC
  RESTRICTED
  PRIVATE
  UPON_REQUEST
  UNKNOWN
}

enum OutcomeCategory {
  EFFICACY
  SAFETY
  BIOMARKER
  QUALITY_OF_LIFE
  PHARMACOKINETIC
  PHARMACODYNAMIC
  ECONOMIC
  OTHER
}

enum PolarityHint {
  HIGHER_IS_BETTER
  LOWER_IS_BETTER
  NEUTRAL
  CONTEXT_DEPENDENT
  UNKNOWN
}

enum OutcomeDomain {
  CARDIOVASCULAR
  METABOLIC
  COGNITIVE
  MUSCULOSKELETAL
  IMMUNOLOGICAL
  HORMONAL
  GASTROINTESTINAL
  RENAL
  HEPATIC
  ONCOLOGICAL
  PSYCHOLOGICAL
  ANTHROPOMETRIC
  OTHER
}

enum OutcomeMeasurementType {
  CONTINUOUS
  BINARY
  ORDINAL
  COUNT
  TIME_TO_EVENT
  COMPOSITE
  OTHER
}

enum EvaluatesTargetKind {
  PRODUCT
  COMPOUND
  COMPOUND_FORM
  FOOD
  FOOD_VARIANT
}

enum StudyEvaluatesRole {
  INTERVENTION
  COMPARATOR
  CO_INTERVENTION
  EXPOSURE
}

enum StudySponsorRole {
  PRIMARY
  COLLABORATOR
  FUNDER
  OTHER
}

enum StudyRunByRole {
  CRO
  SITE
  LAB
  PLATFORM
  OTHER
}

enum StudyInvestigatorRole {
  PI
  COI
  AUTHOR
  SUBINVESTIGATOR
  OTHER
}

enum StudyPopulationRole {
  TARGET
  ENROLLED
  SAFETY
  ITT
  PER_PROTOCOL
  OTHER
}

enum StudyDatasetRole {
  RAW
  CLEANED
  ANALYTIC
  SUMMARY
  OTHER
}

enum StudyInvestigatesRole {
  PRIMARY
  SECONDARY
  COMORBID
  EXCLUSION
  OTHER
}

enum StudyOutcomePriority {
  PRIMARY
  SECONDARY
  EXPLORATORY
}

enum StudyOutcomeRole {
  ENDPOINT
  SAFETY_MONITORING
  BIOMARKER_PANEL
  OTHER
} 

enum EvidenceEdgeType {
  ABOUT
  MENTIONS
  IS_PRIMARY_SOURCE
}  

enum EvidenceSourceKind {
  Document
  Chunk
}  

enum SearchMode {
  FIELD_ONLY
  FULLTEXT_ONLY
  VECTOR_ONLY
  HYBRID
} 

enum SearchReasonKind {
  FULLTEXT_MATCH
  VECTOR_MATCH
  EXACT_MATCH
  FILTER_APPLIED
  BOOST_APPLIED
}  

enum OrganizationSortField {
  NAME
  CREATED_AT
  EMPLOYEE_COUNT_MIN
  EMPLOYEE_COUNT_MAX
}

enum SortDirection {
  ASC
  DESC
} 

enum ProductSortField {
  NAME
  CREATED_AT
  PRICE_AMOUNT
} 

enum AutocompleteEntityType {
  ORGANIZATION
  PRODUCT
} 

enum EmbeddingTargetType {
  ORGANIZATION
  PRODUCT  
  # Add All Other Types that have embeddings on their searchText or other fields 
} 

enum EmbeddingJobStatus {
  QUEUED
  RUNNING
  COMPLETE
  SKIPPED
  FAILED
}

# ============================================================================
# Media (Platform, Channel, Series, Episode, ClaimOccurrence) Enums
# ============================================================================

enum MediaPlatformType {
  video
  podcast
  blog
  social
  newsletter
  aggregator
  other
}

enum MediaSeriesType {
  podcast_series
  youtube_playlist
  lecture_series
  course_series
  other
}

enum ClaimOccurrenceSourceType {
  transcript
  captions
  description
  show_notes
  webpage
  manual
  other
}

enum ClaimOccurrenceExtractionMethod {
  llm
  rules
  human
  hybrid
  other
}

enum TranscriptRole {
  full_transcript
  captions
  partial
  auto_generated
  human_verified
  other
}

enum AppearanceRole {
  host
  co_host
  guest
  panelist
  interviewer
  interviewee
  narrator
  expert
  caller
  other
}

enum ChannelRole {
  host
  co_host
  creator
  producer
  editor
  contributor
  narrator
  guest_host
  other
}

enum TypicalAppearance {
  on_camera
  voice
  behind_scenes
}

enum SponsorshipChannelType {
  exclusive
  primary
  segment_sponsor
  affiliate
  paid_placement
  owned_media
  unknown
}

enum SponsorshipEpisodeType {
  title_sponsor
  midroll
  preroll
  segment_sponsor
  affiliate
  paid_placement
  unknown
}

enum AdReadBy {
  host
  guest
  announcer
  unknown
}

enum SponsorshipSourceType {
  dataset
  description_text
  transcript
  manual
  other
}

enum SeriesPublishRole {
  publisher
  distributor
  network
  production_company
  other
}

# ============================================================================
# Device & Modality Enums
# ============================================================================

enum DeviceClass {
  diagnostic
  monitoring
  therapeutic
  analytical_instrument
  surgical
  implantable
  software_enabled
  other
}

enum DeviceTypeFamily {
  wearable
  benchtop
  handheld
  implant
  consumable
  accessory
  other
}

enum ModalityRole {
  sensing
  actuation
  delivery
  imaging
  analysis
  other
}

enum SensorType {
  optical
  electrochemical
  electrical
  mechanical
  inertial
  thermal
  pressure
  acoustic
  imaging
  other
}

enum FunctionalMetricType {
  physiological
  analytical
  device_performance
  quality
  other
}

enum FunctionalMetricValueType {
  float
  int
  boolean
  categorical
  string
  other
}

enum ModalityParameterValueType {
  float
  int
  string
  boolean
  enum
  range
  other
}
# ===== END: _shared/01-enums.graphql =====

# ===== BEGIN: _shared/02-directives.graphql =====

# ===== END: _shared/02-directives.graphql =====

# ===== BEGIN: _shared/03-interfaces.graphql =====

# ===== END: _shared/03-interfaces.graphql =====

# ===== BEGIN: _shared/04-common-types.graphql =====
input PageInput {
  first: Int! = 20
  after: String
}

"""
Standard page info for cursor pagination.
"""
type PageInfo {
  hasNextPage: Boolean!
  endCursor: String
}
# ===== END: _shared/04-common-types.graphql =====

# ===== BEGIN: _shared/05-common-inputs.graphql =====
input TemporalValidityInput {
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: _shared/05-common-inputs.graphql =====

# ===== BEGIN: roots/00-schema.graphql =====
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
# ===== END: roots/00-schema.graphql =====

# ===== BEGIN: roots/01-roots.graphql =====
"""
Root operation types.
Modules should add fields via `extend type ...`.
"""
type Query
type Mutation
type Subscription
# ===== END: roots/01-roots.graphql =====

# ===== BEGIN: claims/00-types.graphql =====
# ============================================================================
# ClaimOccurrence (instance of a claim in episode/segment)
# ============================================================================

type ClaimOccurrence {
  claimOccurrenceId: ID!
  canonicalText: String!
  normalizedText: String
  occurrenceKey: String
  confidence: Float
  startTimeSec: Int
  endTimeSec: Int
  startChar: Int
  endChar: Int
  language: String
  sourceType: ClaimOccurrenceSourceType
  extractionMethod: ClaimOccurrenceExtractionMethod
  searchText: String
  embedding: [Float!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  occursIn: [ClaimOccurrenceOccursInEdge!]
  occursInSegment: [ClaimOccurrenceOccursInSegmentEdge!]
  utteredBy: [ClaimOccurrenceUtteredByEdge!]
}
# ===== END: claims/00-types.graphql =====

# ===== BEGIN: claims/01-edges.graphql =====
# ============================================================================
# ClaimOccurrence Edges
# ============================================================================

type ClaimOccurrenceOccursInEdge {
  episode: Episode!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type ClaimOccurrenceOccursInSegmentEdge {
  segment: EpisodeSegment!
  startTimeSec: Int
  endTimeSec: Int
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type ClaimOccurrenceUtteredByEdge {
  person: Person!
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: claims/01-edges.graphql =====

# ===== BEGIN: claims/02-inputs.graphql =====

# ===== END: claims/02-inputs.graphql =====

# ===== BEGIN: claims/03-operations.graphql =====

# ===== END: claims/03-operations.graphql =====

# ===== BEGIN: devices_modalities/00-types.graphql =====
# ============================================================================
# Device & Modality types
# ============================================================================

type DeviceType {
  deviceTypeId: ID!
  canonicalName: String!
  description: String
  deviceTypeFamily: DeviceTypeFamily
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type FunctionalMetric {
  functionalMetricId: ID!
  canonicalName: String!
  aliases: [String!]
  description: String
  metricType: FunctionalMetricType
  unit: String
  valueType: FunctionalMetricValueType
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ModalityType {
  modalityTypeId: ID!
  canonicalName: String!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ModalityParameter {
  modalityParameterId: ID!
  canonicalName: String!
  description: String
  parameterKey: String
  valueType: ModalityParameterValueType
  defaultValue: String
  unit: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type Modality {
  modalityId: ID!
  canonicalName: String!
  description: String
  modalityRole: ModalityRole
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  instanceOf: [ModalityInstanceOfEdge!]
  hasParameter: [ModalityHasParameterEdge!]
}

type Sensor {
  sensorId: ID!
  canonicalName: String!
  aliases: [String!]
  description: String
  sensorType: SensorType
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  measuresMetric: [SensorMeasuresMetricEdge!]
}

type Device {
  deviceId: ID!
  canonicalName: String!
  aliases: [String!]
  description: String
  deviceClass: DeviceClass
  intendedUse: String
  version: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  ofType: [DeviceOfTypeEdge!]
  usesModality: [DeviceUsesModalityEdge!]
  hasSensor: [DeviceHasSensorEdge!]
  implementsPlatform: [DeviceImplementsPlatformEdge!]
  measuresMetric: [DeviceMeasuresMetricEdge!]
}
# ===== END: devices_modalities/00-types.graphql =====

# ===== BEGIN: devices_modalities/01-edges.graphql =====
# ============================================================================
# Modality relationship edge types
# ============================================================================

type ModalityInstanceOfEdge {
  modalityType: ModalityType!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ModalityHasParameterEdge {
  modalityParameter: ModalityParameter!
  value: String
  unit: String
  min: Float
  max: Float
  notes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# ============================================================================
# Sensor relationship edge types
# ============================================================================

type SensorMeasuresMetricEdge {
  functionalMetric: FunctionalMetric!
  signalType: String
  unit: String
  samplingRateHz: Float
  notes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# ============================================================================
# Device relationship edge types
# ============================================================================

type DeviceOfTypeEdge {
  deviceType: DeviceType!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DeviceUsesModalityEdge {
  modality: Modality!
  purpose: String
  primary: Boolean
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DeviceHasSensorEdge {
  sensor: Sensor!
  count: Int
  location: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DeviceImplementsPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  notes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DeviceMeasuresMetricEdge {
  functionalMetric: FunctionalMetric!
  method: String
  accuracy: String
  rangeMin: Float
  rangeMax: Float
  unit: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}
# ===== END: devices_modalities/01-edges.graphql =====

# ===== BEGIN: devices_modalities/02-inputs.graphql =====
# ============================================================================
# Device & Modality Inputs — biotech devices and modalities
# ============================================================================
# References: TemporalValidityInput (_shared), TechnologyPlatformInput (composed)
# Enums: DeviceClass, DeviceTypeFamily, ModalityRole, SensorType,
#        FunctionalMetricType, FunctionalMetricValueType, ModalityParameterValueType
# ============================================================================

# ============================================================================
# FunctionalMetric
# ============================================================================

input FunctionalMetricInput {
  functionalMetricId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  metricType: FunctionalMetricType
  unit: String
  valueType: FunctionalMetricValueType
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input FunctionalMetricConnectInput {
  functionalMetricId: ID!
}

input FunctionalMetricConnectByKeyInput {
  canonicalName: String!
}

input FunctionalMetricRelateUpsertInput {
  connect: FunctionalMetricConnectInput
  connectByKey: FunctionalMetricConnectByKeyInput
  upsert: FunctionalMetricInput
}

# ============================================================================
# DeviceType
# ============================================================================

input DeviceTypeInput {
  deviceTypeId: String
  canonicalName: String!
  description: String
  deviceTypeFamily: DeviceTypeFamily
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input DeviceTypeConnectInput {
  deviceTypeId: ID!
}

input DeviceTypeConnectByKeyInput {
  canonicalName: String!
}

input DeviceTypeRelateUpsertInput {
  connect: DeviceTypeConnectInput
  connectByKey: DeviceTypeConnectByKeyInput
  upsert: DeviceTypeInput
}

# ============================================================================
# ModalityType
# ============================================================================

input ModalityTypeInput {
  modalityTypeId: String
  canonicalName: String!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input ModalityTypeConnectInput {
  modalityTypeId: ID!
}

input ModalityTypeConnectByKeyInput {
  canonicalName: String!
}

input ModalityTypeRelateUpsertInput {
  connect: ModalityTypeConnectInput
  connectByKey: ModalityTypeConnectByKeyInput
  upsert: ModalityTypeInput
}

# ============================================================================
# ModalityParameter
# ============================================================================

input ModalityParameterInput {
  modalityParameterId: String
  canonicalName: String!
  description: String
  parameterKey: String
  valueType: ModalityParameterValueType
  defaultValue: String
  unit: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input ModalityParameterConnectInput {
  modalityParameterId: ID!
}

input ModalityParameterConnectByKeyInput {
  canonicalName: String!
}

input ModalityParameterRelateUpsertInput {
  connect: ModalityParameterConnectInput
  connectByKey: ModalityParameterConnectByKeyInput
  upsert: ModalityParameterInput
}

# ============================================================================
# TechnologyPlatform (RelateUpsert for Device.implementsPlatform)
# TechnologyPlatformInput, TechnologyPlatformConnectInput from composed schema
# ============================================================================

input TechnologyPlatformConnectByKeyInput {
  canonicalName: String!
}

input TechnologyPlatformRelateUpsertInput {
  connect: TechnologyPlatformConnectInput
  connectByKey: TechnologyPlatformConnectByKeyInput
  upsert: TechnologyPlatformInput
}

# ============================================================================
# Sensor — edge input then input + RelateUpsert
# ============================================================================

input SensorMeasuresMetricEdgeInput {
  functionalMetric: FunctionalMetricRelateUpsertInput!
  signalType: String
  unit: String
  samplingRateHz: Float
  notes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SensorInput {
  sensorId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  sensorType: SensorType
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  measuresMetric: [SensorMeasuresMetricEdgeInput!]
}

input SensorConnectInput {
  sensorId: ID!
}

input SensorConnectByKeyInput {
  canonicalName: String!
}

input SensorRelateUpsertInput {
  connect: SensorConnectInput
  connectByKey: SensorConnectByKeyInput
  upsert: SensorInput
}

# ============================================================================
# Modality — edge inputs then input + RelateUpsert
# ============================================================================

input ModalityInstanceOfEdgeInput {
  modalityType: ModalityTypeRelateUpsertInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ModalityHasParameterEdgeInput {
  modalityParameter: ModalityParameterRelateUpsertInput!
  value: String
  unit: String
  min: Float
  max: Float
  notes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ModalityInput {
  modalityId: String
  canonicalName: String!
  description: String
  modalityRole: ModalityRole
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  instanceOf: [ModalityInstanceOfEdgeInput!]
  hasParameter: [ModalityHasParameterEdgeInput!]
}

input ModalityConnectInput {
  modalityId: ID!
}

input ModalityConnectByKeyInput {
  canonicalName: String!
}

input ModalityRelateUpsertInput {
  connect: ModalityConnectInput
  connectByKey: ModalityConnectByKeyInput
  upsert: ModalityInput
}

# ============================================================================
# Device — edge inputs then input + RelateUpsert
# ============================================================================

input DeviceOfTypeEdgeInput {
  deviceType: DeviceTypeRelateUpsertInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeviceUsesModalityEdgeInput {
  modality: ModalityRelateUpsertInput!
  purpose: String
  primary: Boolean
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeviceHasSensorEdgeInput {
  sensor: SensorRelateUpsertInput!
  count: Int
  location: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeviceImplementsPlatformEdgeInput {
  technologyPlatform: TechnologyPlatformRelateUpsertInput!
  notes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeviceMeasuresMetricEdgeInput {
  functionalMetric: FunctionalMetricRelateUpsertInput!
  method: String
  accuracy: String
  rangeMin: Float
  rangeMax: Float
  unit: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeviceInput {
  deviceId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  deviceClass: DeviceClass
  intendedUse: String
  version: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  ofType: [DeviceOfTypeEdgeInput!]
  usesModality: [DeviceUsesModalityEdgeInput!]
  hasSensor: [DeviceHasSensorEdgeInput!]
  implementsPlatform: [DeviceImplementsPlatformEdgeInput!]
  measuresMetric: [DeviceMeasuresMetricEdgeInput!]
}

input DeviceConnectInput {
  deviceId: ID!
}

input DeviceConnectByKeyInput {
  canonicalName: String!
}

input DeviceRelateUpsertInput {
  connect: DeviceConnectInput
  connectByKey: DeviceConnectByKeyInput
  upsert: DeviceInput
}

# ============================================================================
# Upsert Inputs (for mutations)
# ============================================================================

input UpsertFunctionalMetricInput {
  functionalMetricId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  metricType: FunctionalMetricType
  unit: String
  valueType: FunctionalMetricValueType
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input UpsertDeviceTypeInput {
  deviceTypeId: String
  canonicalName: String!
  description: String
  deviceTypeFamily: DeviceTypeFamily
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input UpsertModalityTypeInput {
  modalityTypeId: String
  canonicalName: String!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input UpsertModalityParameterInput {
  modalityParameterId: String
  canonicalName: String!
  description: String
  parameterKey: String
  valueType: ModalityParameterValueType
  defaultValue: String
  unit: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input UpsertSensorInput {
  sensorId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  sensorType: SensorType
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  measuresMetric: [SensorMeasuresMetricEdgeInput!]
}

input UpsertModalityInput {
  modalityId: String
  canonicalName: String!
  description: String
  modalityRole: ModalityRole
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  instanceOf: [ModalityInstanceOfEdgeInput!]
  hasParameter: [ModalityHasParameterEdgeInput!]
}

input UpsertDeviceInput {
  deviceId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  deviceClass: DeviceClass
  intendedUse: String
  version: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  ofType: [DeviceOfTypeEdgeInput!]
  usesModality: [DeviceUsesModalityEdgeInput!]
  hasSensor: [DeviceHasSensorEdgeInput!]
  implementsPlatform: [DeviceImplementsPlatformEdgeInput!]
  measuresMetric: [DeviceMeasuresMetricEdgeInput!]
}
# ===== END: devices_modalities/02-inputs.graphql =====

# ===== BEGIN: devices_modalities/03-operations.graphql =====
extend type Mutation {
  upsertFunctionalMetric(input: UpsertFunctionalMetricInput!): FunctionalMetric!
  upsertDeviceType(input: UpsertDeviceTypeInput!): DeviceType!
  upsertModalityType(input: UpsertModalityTypeInput!): ModalityType!
  upsertSensor(input: UpsertSensorInput!): Sensor!
  upsertModality(input: UpsertModalityInput!): Modality!
  upsertDevice(input: UpsertDeviceInput!): Device!
}
# ===== END: devices_modalities/03-operations.graphql =====

# ===== BEGIN: ingestion/00-types.graphql =====
type ResearchPlanRef {
  researchPlanRefId: ID!
  mongoPlanId: String!
  label: String
  version: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ResearchRunRef {
  researchRunRefId: ID!
  mongoRunId: String!
  label: String
  startedAt: DateTime!
  endedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  usesPlan: [UsesPlanEdge!]
} 


type DocumentTextVersion {
  documentTextVersionId: ID!
  textVersionHash: String!
  source: String!
  language: String
  text: String!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
  hasSegmentation: [HasSegmentationEdge!]
}

type Segmentation {
  segmentationId: ID!
  segmentationHash: String!
  strategy: String!
  chunkSize: Int!
  overlap: Int!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  hasChunk: [SegmentationHasChunkEdge!]
}

type Chunk {
  chunkId: ID!
  chunkKey: String!
  index: Int!
  text: String!
  charStart: Int
  charEnd: Int
  startMs: Int
  endMs: Int
  embedding: [Float!]
  embeddingModel: String
  embeddingVersion: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  nextChunk: NextChunkEdge
  mentions: [MentionsEdge!]
  about: [AboutEdge!]
}

type Document {
  documentId: ID!
  documentKey: String!
  type: String!
  title: String
  url: String
  publishedAt: DateTime!
  retrievedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
  hasTextVersion: [HasTextVersionEdge!]
  chunks: [HasChunkEdge!]
  generatedBy: [GeneratedByEdge!]
} 


union EvidenceSourceRefResult = EvidenceSourceRefDocumentResult | EvidenceSourceRefChunkResult

type EvidenceSourceRefDocumentResult {
  kind: EvidenceSourceKind! # Always "Document"
  documentId: String!
}

type EvidenceSourceRefChunkResult {
  kind: EvidenceSourceKind! # Always "Chunk"
  chunkId: String!
}

type EvidenceTargetRefResolved {
  nodeId: String!
  label: String!
  uniqueKey: String
  uniqueKeyValue: String
}

type UpsertEvidenceEdgeResult {
  ok: Boolean! # Always true for successful results
  edgeType: EvidenceEdgeType!
  relKey: String!
  relationshipId: String
  
  source: EvidenceSourceRefResult!
  target: EvidenceTargetRefResolved!
  
  created: Boolean!
  updated: Boolean!
}

type UpsertEvidenceEdgeError {
  index: Int!
  edgeType: EvidenceEdgeType
  message: String!
  code: String
}

type UpsertEvidenceEdgesCounts {
  received: Int!
  attempted: Int!
  created: Int!
  updated: Int!
  failed: Int!
}

type UpsertEvidenceEdgesResult {
  ok: Boolean!
  counts: UpsertEvidenceEdgesCounts!
  results: [UpsertEvidenceEdgeResult!]!
  errors: [UpsertEvidenceEdgeError!]!
} 

type UpsertEmbeddingResult {
  targetType: EmbeddingTargetType!
  targetId: ID!
  status: EmbeddingJobStatus!
  message: String 
  jobId: String 
} 

type EmbeddingJobEvent {
  targetType: EmbeddingTargetType!
  targetId: ID!
  status: EmbeddingJobStatus!
  jobId: String
  requestId: String
  message: String
  error: String
  updatedAt: DateTime!
} 


type UpsertDocumentTextVersionBundleResult {
  documentId: String!
  documentTextVersionId: String!
  segmentationId: String!
  chunkMetas: [ChunkMeta!]!
  nextChunkEdgesCreated: Boolean!
}

type ChunkMeta {
  chunkId: String!
  chunkKey: String!
  index: Int!
}
# ===== END: ingestion/00-types.graphql =====

# ===== BEGIN: ingestion/01-edges.graphql =====
type UsesPlanEdge {
  researchPlanRef: ResearchPlanRef!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasSegmentationEdge {
  segmentation: Segmentation!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type SegmentationHasChunkEdge {
  chunk: Chunk!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type NextChunkEdge {
  chunk: Chunk!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type MentionsEdge {
  # Target node properties will be resolved at query time
  # For now, we include provenance fields that are on the relationship
  confidence: Float
  linkingMethod: String
  surfaceForm: String
  # Provenance fields (also on relationship)
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type AboutEdge {
  # Target node properties will be resolved at query time
  # For now, we include relationship-specific properties
  aboutness: Float
  aspect: String
  stance: String
  # Provenance fields (also on relationship)
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasTextVersionEdge {
  documentTextVersion: DocumentTextVersion!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasChunkEdge {
  chunk: Chunk!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type GeneratedByEdge {
  researchRunRef: ResearchRunRef!
  operation: String!
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}
# ===== END: ingestion/01-edges.graphql =====

# ===== BEGIN: ingestion/02-inputs.graphql =====
input UpsertDocumentInput {
  documentKey: String!
  type: String!
  title: String
  url: String
  publishedAt: DateTime
  retrievedAt: DateTime
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  searchSurface: SearchSurfaceInput
  generatedBy: DocumentGeneratedByInput
  chunkBundle: InlineChunkBundleInput
}

input DocumentTextVersionInput {
  textVersionHash: String!
  source: String!
  language: String
  text: String!
  searchSurface: SearchSurfaceInput
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input SegmentationInput {
  segmentationHash: String!
  strategy: String!
  chunkSize: Int!
  overlap: Int!
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ChunkInput {
  chunkKey: String!
  index: Int!
  text: String!
  charStart: Int
  charEnd: Int
  startMs: Int
  endMs: Int
  embedding: [Float!]
  embeddingModel: String
  embeddingVersion: String
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UpsertDocumentTextVersionBundleInput {
  documentId: String!
  textVersion: DocumentTextVersionInput!
  segmentation: SegmentationInput!
  chunks: [ChunkInput!]!
  hasTextVersionEdge: TemporalValidityInput
  hasSegmentationEdge: TemporalValidityInput
  segmentationHasChunkEdge: TemporalValidityInput
  documentHasChunkEdge: TemporalValidityInput
  nextChunkEdge: TemporalValidityInput
  alsoCreateDocumentHasChunkEdges: Boolean = true
  alsoCreateNextChunkEdges: Boolean = true
} 


input EvidenceProvenanceInput {
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
}

# ============================================================================
# Evidence Source Reference Input (Discriminated Union)
# ============================================================================

input EvidenceSourceRefInput {
  kind: EvidenceSourceKind!
  # For kind="Document", provide documentId
  documentId: String
  # For kind="Chunk", provide chunkId
  chunkId: String
} 


# ============================================================================
# Evidence Target Reference Input
# ============================================================================
# Prefer nodeId; allow fallback resolution using label + uniqueKey + uniqueKeyValue

input EvidenceTargetRefInput {
  nodeId: String
  
  # Fallback fields (only used if nodeId is missing)
  label: String
  uniqueKey: String
  uniqueKeyValue: String
}

# copied to ingestion inputs 

# ============================================================================
# Evidence Edge Property Inputs
# ============================================================================

input AboutEdgePropsInput {
  # Temporal validity fields
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # About-specific fields
  aboutness: Float
  aspect: String
  stance: String
  confidence: Float
}

input MentionsEdgePropsInput {
  # Temporal validity fields
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # Mentions-specific fields
  confidence: Float
  linkingMethod: String
  surfaceForm: String
  charStart: Int
  charEnd: Int
}

input IsPrimarySourceEdgePropsInput {
  # Temporal validity fields
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # IS_PRIMARY_SOURCE-specific fields
  confidence: Float
  notes: String
}

# ============================================================================
# Evidence Edge Input Types
# ============================================================================
# Note: GraphQL doesn't support union input types, so we use a flattened discriminated union pattern.
# The resolver should validate that the correct fields are provided based on the "type" field.
# All edge-specific property fields are flattened into EvidenceEdgeInput for simplicity.

input EvidenceEdgeInput {
  type: EvidenceEdgeType!
  source: EvidenceSourceRefInput!
  target: EvidenceTargetRefInput!
  
  # Temporal validity fields (common to all edge types)
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  
  # Provenance fields (common to all edge types)
  mongoRunId: String!
  mongoPlanId: String
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime!
  
  # ABOUT edge specific fields (used when type="ABOUT")
  aboutness: Float
  aspect: String
  stance: String
  
  # MENTIONS edge specific fields (used when type="MENTIONS")
  linkingMethod: String
  surfaceForm: String
  charStart: Int
  charEnd: Int
  
  # IS_PRIMARY_SOURCE edge specific fields (used when type="IS_PRIMARY_SOURCE")
  notes: String
  
  # Confidence (used by ABOUT, MENTIONS, and IS_PRIMARY_SOURCE)
  confidence: Float
} 


input UpsertEmbeddingInput {
  targetType: EmbeddingTargetType!
  targetId: ID! 

  # Optional: let you override rules (rarely used)
  force: Boolean = false 

  requestId: String 
}

input UpsertEvidenceEdgesInput {
  edges: [EvidenceEdgeInput!]!
} 

input UpsertResearchPlanRefInput {
  mongoPlanId: String!
  label: String
  version: String
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UpsertResearchRunRefInput {
  mongoRunId: String!
  label: String
  startedAt: DateTime
  endedAt: DateTime
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

input LinkResearchRunUsesPlanInput {
  mongoRunId: String!
  mongoPlanId: String!
  validAt: DateTime
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input DocumentGeneratedByInput {
  mongoRunId: String!
  operation: String!
  stageKey: String
  subStageKey: String
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input InlineChunkBundleSyntheticInput {
  source: String
  strategy: String
  chunkSize: Int
  overlap: Int
}

input InlineChunkBundleInput {
  textVersion: DocumentTextVersionInput
  segmentation: SegmentationInput
  chunks: [ChunkInput!]!
  hasTextVersionEdge: TemporalValidityInput
  hasSegmentationEdge: TemporalValidityInput
  segmentationHasChunkEdge: TemporalValidityInput
  documentHasChunkEdge: TemporalValidityInput
  nextChunkEdge: TemporalValidityInput
  alsoCreateDocumentHasChunkEdges: Boolean = true
  alsoCreateNextChunkEdges: Boolean = true
  synthetic: InlineChunkBundleSyntheticInput
}
# ===== END: ingestion/02-inputs.graphql =====

# ===== BEGIN: ingestion/03-operations.graphql =====
extend type Mutation { 
  upsertEmbedding(input: UpsertEmbeddingInput!): UpsertEmbeddingResult! 
  upsertEmbeddings(inputs: [UpsertEmbeddingInput!]!): [UpsertEmbeddingResult!]!  
  upsertResearchPlanRef(input: UpsertResearchPlanRefInput!): ResearchPlanRef! 
  upsertResearchRunRef(input: UpsertResearchRunRefInput!): ResearchRunRef!  
  linkResearchRunUsesPlan(input: LinkResearchRunUsesPlanInput!): ResearchRunRef! 
  upsertDocument(input: UpsertDocumentInput!): Document!   
  upsertDocumentTextVersionBundle(input: UpsertDocumentTextVersionBundleInput!): UpsertDocumentTextVersionBundleResult! 
  upsertEvidenceEdge(input: EvidenceEdgeInput!): UpsertEvidenceEdgeResult!
  upsertEvidenceEdges(input: [UpsertEvidenceEdgesInput!]!): [UpsertEvidenceEdgesResult!]!
} 


extend type Subscription { 
     embeddingJobEvents(targetType: EmbeddingTargetType!, targetID: ID): EmbeddingJobEvent! 
  documentIngested(documentId: String): Document! 
  documentTextVersionBundleIngested(documentTextVersionId: String): UpsertDocumentTextVersionBundleResult! 
  evidenceEdgeUpserted(relKey: String): UpsertEvidenceEdgeResult!  
}
# ===== END: ingestion/03-operations.graphql =====

# ===== BEGIN: labs/00-types.graphql =====
type LabTest {
  labTestId: ID!
  name: String!
  synonyms: [String!]
  loincCodes: [String!]
  cptCodes: [String!]
  whatItMeasures: String
  prepRequirements: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  # Relationships
  measures: [MeasuresBiomarkerEdge!]
  usesMethod: [UsesMethodEdge!]
  requiresSpecimen: [RequiresSpecimenEdge!]
  usesPlatform: [LabTestUsesPlatformEdge!]
} 

type PanelDefinition {
  panelDefinitionId: ID!
  canonicalName: String!
  aliases: [String!]
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  # Relationships
  includesLabTest: [IncludesLabTestEdge!]
  includesBiomarker: [IncludesBiomarkerEdge!]
}

type Biomarker {
  biomarkerId: ID!
  name: String!
  synonyms: [String!]
  description: String
  clinicalDomains: [String!]
  unitsCommon: [String!]
  interpretationNotes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type MeasurementMethod {
  methodId: ID!
  canonicalName: String!
  methodFamily: String!
  analyticPrinciple: String
  typicalCvPercentMin: Float
  typicalCvPercentMax: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type Specimen {
  specimenId: ID!
  canonicalName: String!
  specimenType: String!
  matrix: String
  biologicalDomain: String!
  collectionContextCategory: String!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
} 

type CompoundForm {
  compoundFormId: ID!
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}
# ===== END: labs/00-types.graphql =====

# ===== BEGIN: labs/01-edges.graphql =====
type MeasuresBiomarkerEdge {
  biomarker: Biomarker!
  role: BiomarkerRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type UsesMethodEdge {
  measurementMethod: MeasurementMethod!
  methodRole: MethodRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type RequiresSpecimenEdge {
  specimen: Specimen!
  specimenRole: SpecimenRole!
  collectionSetting: CollectionSetting
  collectionMethod: CollectionMethod
  fastingRequired: Boolean
  fastingMinHours: Int
  fastingMaxHours: Int
  requiresAppointment: Boolean
  requiresColdChainDuringCollection: Boolean
  collectionTimeWindow: CollectionTimeWindow
  collectionNotes: String
  processingMustCentrifuge: Boolean
  processingCentrifugeWithinMinutes: Int
  processingAliquotRequired: Boolean
  processingAdditive: ProcessingAdditive
  processingLightSensitive: Boolean
  processingMixInversions: Int
  processingMaxRoomTempMinutes: Int
  processingNotes: String
  stabilityAtRoomTempMaxHours: Int
  stabilityRefrigeratedMaxHours: Int
  stabilityFrozenMaxDays: Int
  stabilityMinTempC: Float
  stabilityMaxTempC: Float
  stabilityRequiresColdChain: Boolean
  stabilityNotes: String
  populationTags: [String!]
  sex: Sex
  ageMinYears: Int
  ageMaxYears: Int
  measurementState: MeasurementState
  timeOfDay: TimeOfDay
  conditionTags: [String!]
  medicationClassTags: [String!]
  comorbidityTags: [String!]
  appliesWhen: AppliesWhen
  thresholdDirection: ThresholdDirection
  thresholdValue: Float
  thresholdUnit: String
  evidenceContextTags: [String!]
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type LabTestUsesPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# PanelDefinition Relationship Edge Types

type IncludesLabTestEdge {
  labTest: LabTest!
  required: Boolean
  quantity: Int
  notes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type IncludesBiomarkerEdge {
  biomarker: Biomarker!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}
# ===== END: labs/01-edges.graphql =====

# ===== BEGIN: labs/02-inputs.graphql =====
input CompoundFormInput {
  compoundFormId: ID
  canonicalName: String!
  formType: String!
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
} 


input CompoundFormRelateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
}

input CompoundFormRelateUpdateInput {
  create: CompoundFormInput
  connect: CompoundFormConnectInput
  update: CompoundFormUpdateInput
}

input CompoundFormConnectInput {
  compoundFormId: ID!
} 

input LabTestInput {
  labTestId: ID
  name: String!
  synonyms: [String!]
  loincCodes: [String!]
  cptCodes: [String!]
  whatItMeasures: String
  prepRequirements: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  measures: [MeasuresBiomarkerRelationshipInput!]
  usesMethod: [UsesMethodRelationshipInput!]
  requiresSpecimen: [RequiresSpecimenRelationshipInput!]
  usesPlatform: [LabTestUsesPlatformRelationshipInput!]
}  


input LabTestRelateInput {
  create: LabTestInput
  connect: LabTestConnectInput
}

input LabTestRelateUpdateInput {
  create: LabTestInput
  connect: LabTestConnectInput
  update: UpdateLabTestInput
}

input LabTestConnectInput {
  labTestId: ID!
} 

input PanelDefinitionInput {
  panelDefinitionId: ID
  canonicalName: String!
  aliases: [String!]
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  includesLabTest: [IncludesLabTestRelationshipInput!]
  includesBiomarker: [IncludesBiomarkerRelationshipInput!]
}

input BiomarkerInput {
  biomarkerId: ID
  name: String!
  synonyms: [String!]
  description: String
  clinicalDomains: [String!]
  unitsCommon: [String!]
  interpretationNotes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input MeasurementMethodInput {
  methodId: ID
  canonicalName: String!
  methodFamily: String!
  analyticPrinciple: String
  typicalCvPercentMin: Float
  typicalCvPercentMax: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SpecimenInput {
  specimenId: ID
  canonicalName: String!
  specimenType: String!
  matrix: String
  biologicalDomain: String!
  collectionContextCategory: String!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}  

input PanelDefinitionRelateInput {
  create: PanelDefinitionInput
  connect: PanelDefinitionConnectInput
}

input PanelDefinitionRelateUpdateInput {
  create: PanelDefinitionInput
  connect: PanelDefinitionConnectInput
  update: UpdatePanelDefinitionInput
}

input PanelDefinitionConnectInput {
  panelDefinitionId: ID!
}

input BiomarkerRelateInput {
  create: BiomarkerInput
  connect: BiomarkerConnectInput
}

input BiomarkerRelateUpdateInput {
  create: BiomarkerInput
  connect: BiomarkerConnectInput
  update: UpdateBiomarkerInput
}

input BiomarkerConnectInput {
  biomarkerId: ID!
}

input MeasurementMethodRelateInput {
  create: MeasurementMethodInput
  connect: MeasurementMethodConnectInput
}

input MeasurementMethodRelateUpdateInput {
  create: MeasurementMethodInput
  connect: MeasurementMethodConnectInput
  update: MeasurementMethodUpdateInput
}

input MeasurementMethodConnectInput {
  methodId: ID!
}

input SpecimenRelateInput {
  create: SpecimenInput
  connect: SpecimenConnectInput
}

input SpecimenRelateUpdateInput {
  create: SpecimenInput
  connect: SpecimenConnectInput
  update: SpecimenUpdateInput
}

input SpecimenConnectInput {
  specimenId: ID!
}

input CompoundFormUpdateInput {
  compoundFormId: ID
  canonicalName: String
  formType: String
  chemicalDifferences: String
  stabilityProfile: String
  solubilityProfile: String
  bioavailabilityNotes: String
  regulatoryStatusSummary: String
}

input UpdateLabTestInput {
  labTestId: ID
  name: String
  synonyms: [String!]
  loincCodes: [String!]
  cptCodes: [String!]
  whatItMeasures: String
  prepRequirements: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  measures: [MeasuresBiomarkerRelationshipUpdateInput!]
  usesMethod: [UsesMethodRelationshipUpdateInput!]
  requiresSpecimen: [RequiresSpecimenRelationshipUpdateInput!]
  usesPlatform: [LabTestUsesPlatformRelationshipUpdateInput!]
} 

input UpdatePanelDefinitionInput {
  panelDefinitionId: ID
  canonicalName: String
  aliases: [String!]
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  includesLabTest: [IncludesLabTestRelationshipUpdateInput!]
  includesBiomarker: [IncludesBiomarkerRelationshipUpdateInput!]
} 

input UpdateBiomarkerInput {
  biomarkerId: ID
  name: String
  synonyms: [String!]
  description: String
  clinicalDomains: [String!]
  unitsCommon: [String!]
  interpretationNotes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input MeasurementMethodUpdateInput {
  methodId: ID
  canonicalName: String
  methodFamily: String
  analyticPrinciple: String
  typicalCvPercentMin: Float
  typicalCvPercentMax: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SpecimenUpdateInput {
  specimenId: ID
  canonicalName: String
  specimenType: String
  matrix: String
  biologicalDomain: String
  collectionContextCategory: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
} 

input MeasuresBiomarkerRelationshipInput {
  biomarker: BiomarkerRelateInput!
  role: BiomarkerRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input MeasuresBiomarkerRelationshipUpdateInput {
  biomarker: BiomarkerRelateUpdateInput!
  role: BiomarkerRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesMethodRelationshipInput {
  measurementMethod: MeasurementMethodRelateInput!
  methodRole: MethodRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesMethodRelationshipUpdateInput {
  measurementMethod: MeasurementMethodRelateUpdateInput!
  methodRole: MethodRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RequiresSpecimenRelationshipInput {
  specimen: SpecimenRelateInput!
  specimenRole: SpecimenRole!
  collectionSetting: CollectionSetting
  collectionMethod: CollectionMethod
  fastingRequired: Boolean
  fastingMinHours: Int
  fastingMaxHours: Int
  requiresAppointment: Boolean
  requiresColdChainDuringCollection: Boolean
  collectionTimeWindow: CollectionTimeWindow
  collectionNotes: String
  processingMustCentrifuge: Boolean
  processingCentrifugeWithinMinutes: Int
  processingAliquotRequired: Boolean
  processingAdditive: ProcessingAdditive
  processingLightSensitive: Boolean
  processingMixInversions: Int
  processingMaxRoomTempMinutes: Int
  processingNotes: String
  stabilityAtRoomTempMaxHours: Int
  stabilityRefrigeratedMaxHours: Int
  stabilityFrozenMaxDays: Int
  stabilityMinTempC: Float
  stabilityMaxTempC: Float
  stabilityRequiresColdChain: Boolean
  stabilityNotes: String
  populationTags: [String!]
  sex: Sex
  ageMinYears: Int
  ageMaxYears: Int
  measurementState: MeasurementState
  timeOfDay: TimeOfDay
  conditionTags: [String!]
  medicationClassTags: [String!]
  comorbidityTags: [String!]
  appliesWhen: AppliesWhen
  thresholdDirection: ThresholdDirection
  thresholdValue: Float
  thresholdUnit: String
  evidenceContextTags: [String!]
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RequiresSpecimenRelationshipUpdateInput {
  specimen: SpecimenRelateUpdateInput!
  specimenRole: SpecimenRole
  collectionSetting: CollectionSetting
  collectionMethod: CollectionMethod
  fastingRequired: Boolean
  fastingMinHours: Int
  fastingMaxHours: Int
  requiresAppointment: Boolean
  requiresColdChainDuringCollection: Boolean
  collectionTimeWindow: CollectionTimeWindow
  collectionNotes: String
  processingMustCentrifuge: Boolean
  processingCentrifugeWithinMinutes: Int
  processingAliquotRequired: Boolean
  processingAdditive: ProcessingAdditive
  processingLightSensitive: Boolean
  processingMixInversions: Int
  processingMaxRoomTempMinutes: Int
  processingNotes: String
  stabilityAtRoomTempMaxHours: Int
  stabilityRefrigeratedMaxHours: Int
  stabilityFrozenMaxDays: Int
  stabilityMinTempC: Float
  stabilityMaxTempC: Float
  stabilityRequiresColdChain: Boolean
  stabilityNotes: String
  populationTags: [String!]
  sex: Sex
  ageMinYears: Int
  ageMaxYears: Int
  measurementState: MeasurementState
  timeOfDay: TimeOfDay
  conditionTags: [String!]
  medicationClassTags: [String!]
  comorbidityTags: [String!]
  appliesWhen: AppliesWhen
  thresholdDirection: ThresholdDirection
  thresholdValue: Float
  thresholdUnit: String
  evidenceContextTags: [String!]
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input LabTestUsesPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input LabTestUsesPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# PanelDefinition Relationship Input Types
# ============================================================================

input IncludesLabTestRelationshipInput {
  labTest: LabTestRelateInput!
  required: Boolean
  quantity: Int
  notes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input IncludesLabTestRelationshipUpdateInput {
  labTest: LabTestRelateUpdateInput!
  required: Boolean
  quantity: Int
  notes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input IncludesBiomarkerRelationshipInput {
  biomarker: BiomarkerRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input IncludesBiomarkerRelationshipUpdateInput {
  biomarker: BiomarkerRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: labs/02-inputs.graphql =====

# ===== BEGIN: labs/03-operations.graphql =====
extend type Mutation { 
     createLabTest(input: LabTestInput!): LabTest!
  updateLabTest(input: UpdateLabTestInput!): LabTest!
  createPanelDefinition(input: PanelDefinitionInput!): PanelDefinition!
  updatePanelDefinition(input: UpdatePanelDefinitionInput!): PanelDefinition!
  createBiomarker(input: BiomarkerInput!): Biomarker!
  updateBiomarker(input: UpdateBiomarkerInput!): Biomarker!
}
# ===== END: labs/03-operations.graphql =====

# ===== BEGIN: media/00-types.graphql =====
# ============================================================================
# Platform (Media distribution: YouTube, Spotify, etc.)
# ============================================================================

type Platform {
  platformId: ID!
  canonicalName: String!
  aliases: [String!]
  platformType: MediaPlatformType!
  description: String
  websiteUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  hostsChannel: [PlatformHostsChannelEdge!]
}

# ============================================================================
# Channel (publisher identity on a platform — e.g. YouTube channel, podcast feed)
# ============================================================================

type Channel {
  channelId: ID!
  canonicalName: String!
  aliases: [String!]
  description: String
  channelHandle: String
  platformChannelId: String
  webPageUrl: String
  rssUrl: String
  imageUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  onPlatform: [ChannelOnPlatformEdge!]
  hasSeries: [ChannelHasSeriesEdge!]
  hasEpisode: [ChannelHasEpisodeEdge!]
}

# ============================================================================
# Series (show / playlist / feed grouping under a channel)
# ============================================================================

type Series {
  seriesId: ID!
  canonicalName: String!
  aliases: [String!]
  description: String
  seriesType: MediaSeriesType!
  webPageUrl: String
  imageUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  inChannel: [SeriesInChannelEdge!]
  includesEpisode: [SeriesIncludesEpisodeEdge!]
}

# ============================================================================
# Episode (single published media item)
# ============================================================================

type Episode {
  episodeId: ID!
  canonicalName: String!
  description: String
  publishedAt: DateTime
  durationSec: Int
  language: String
  s3TranscriptUrl: String
  transcriptUrl: String
  webPageUrl: String
  webPageSummary: String
  searchText: String
  embedding: [Float!]
  youtubeUrl: String
  youtubeWatchUrl: String
  youtubeEmbedUrl: String
  socialUrlsJson: String
  timestampsJson: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  hasSegment: [EpisodeHasSegmentEdge!]
  inChannel: [EpisodeInChannelEdge!]
  inSeries: [EpisodeInSeriesEdge!]
  onPlatform: [EpisodeOnPlatformEdge!]
  hasTranscript: [EpisodeHasTranscriptEdge!]
}

# ============================================================================
# EpisodeSegment (timestamp-anchored segment within an episode)
# ============================================================================

type EpisodeSegment {
  episodeSegmentId: ID!
  canonicalName: String!
  description: String
  orderIndex: Int
  startTimeSec: Int
  endTimeSec: Int
  timeRangeJson: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  inEpisode: [EpisodeSegmentInEpisodeEdge!]
}
# ===== END: media/00-types.graphql =====

# ===== BEGIN: media/01-edges.graphql =====
# ============================================================================
# Platform Graph
# ============================================================================

type PlatformHostsChannelEdge {
  channel: Channel!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type ChannelOnPlatformEdge {
  platform: Platform!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Channel ↔ Series ↔ Episode
# ============================================================================

type ChannelHasSeriesEdge {
  series: Series!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type SeriesInChannelEdge {
  channel: Channel!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type ChannelHasEpisodeEdge {
  episode: Episode!
  publishedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type SeriesIncludesEpisodeEdge {
  episode: Episode!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type EpisodeInChannelEdge {
  channel: Channel!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type EpisodeInSeriesEdge {
  series: Series!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type EpisodeOnPlatformEdge {
  platform: Platform!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Episode Segments
# ============================================================================

type EpisodeHasSegmentEdge {
  segment: EpisodeSegment!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type EpisodeSegmentInEpisodeEdge {
  episode: Episode!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Transcripts (Episode -> Document)
# ============================================================================

type EpisodeHasTranscriptEdge {
  document: Document!
  role: TranscriptRole
  rank: Int
  updatedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: media/01-edges.graphql =====

# ===== BEGIN: media/02-inputs.graphql =====
# ============================================================================
# Platform Inputs
# ============================================================================

input PlatformInput {
  platformId: String
  canonicalName: String!
  aliases: [String!]
  platformType: MediaPlatformType!
  description: String
  websiteUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input PlatformConnectInput {
  platformId: ID!
}

input PlatformConnectByKeyInput {
  canonicalName: String!
}

input PlatformRelateUpsertInput {
  connect: PlatformConnectInput
  connectByKey: PlatformConnectByKeyInput
  upsert: PlatformInput
}

# ============================================================================
# Series Inputs
# ============================================================================

input SeriesInput {
  seriesId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  seriesType: MediaSeriesType!
  webPageUrl: String
  imageUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input SeriesConnectInput {
  seriesId: ID!
}

input SeriesConnectByKeyInput {
  channelId: String!
  canonicalName: String!
}

input SeriesRelateUpsertInput {
  connect: SeriesConnectInput
  connectByKey: SeriesConnectByKeyInput
  upsert: SeriesInput
}

# ============================================================================
# EpisodeSegment Inputs
# ============================================================================

input EpisodeSegmentInput {
  episodeSegmentId: String
  canonicalName: String!
  description: String
  orderIndex: Int
  startTimeSec: Int
  endTimeSec: Int
  timeRangeJson: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
}

input EpisodeSegmentConnectInput {
  episodeSegmentId: ID!
}

input EpisodeSegmentConnectByKeyInput {
  episodeId: String!
  orderIndex: Int!
}

input EpisodeSegmentRelateUpsertInput {
  connect: EpisodeSegmentConnectInput
  connectByKey: EpisodeSegmentConnectByKeyInput
  upsert: EpisodeSegmentInput
}

# ============================================================================
# Channel Inputs
# ============================================================================

input ChannelInput {
  channelId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  channelHandle: String
  platformChannelId: String
  webPageUrl: String
  rssUrl: String
  imageUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  onPlatform: [PlatformHostsChannelEdgeInput!]
  hasSeries: [ChannelHasSeriesEdgeInput!]
  hasEpisode: [ChannelHasEpisodeEdgeInput!]
}

input ChannelConnectInput {
  channelId: ID!
}

input ChannelConnectByKeyInput {
  platformId: String!
  platformChannelId: String
  channelHandle: String
}

input ChannelRelateUpsertInput {
  connect: ChannelConnectInput
  connectByKey: ChannelConnectByKeyInput
  upsert: ChannelInput
}

# ============================================================================
# Channel Edge Inputs
# ============================================================================

input PlatformHostsChannelEdgeInput {
  channel: ChannelRelateUpsertInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PlatformOnChannelEdgeInput {
  platform: PlatformRelateUpsertInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ChannelHasSeriesEdgeInput {
  series: SeriesRelateUpsertInput!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ChannelHasEpisodeEdgeInput {
  episode: EpisodeRelateUpsertInput!
  publishedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Episode Inputs
# ============================================================================

input EpisodeInput {
  episodeId: String
  canonicalName: String!
  description: String
  publishedAt: DateTime
  durationSec: Int
  language: String
  s3TranscriptUrl: String
  transcriptUrl: String
  webPageUrl: String
  webPageSummary: String
  searchText: String
  embedding: String
  youtubeUrl: String
  youtubeWatchUrl: String
  youtubeEmbedUrl: String
  socialUrlsJson: String
  timestampsJson: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  inChannel: [EpisodeInChannelEdgeInput!]
  inSeries: [EpisodeInSeriesEdgeInput!]
  onPlatform: [EpisodeOnPlatformEdgeInput!]
  hasSegment: [EpisodeHasSegmentEdgeInput!]
}

input EpisodeConnectInput {
  episodeId: ID!
}

input EpisodeConnectByKeyInput {
  webPageUrl: String!
}

input EpisodeRelateUpsertInput {
  connect: EpisodeConnectInput
  connectByKey: EpisodeConnectByKeyInput
  upsert: EpisodeInput
}

# ============================================================================
# Episode Edge Inputs
# ============================================================================

input EpisodeInChannelEdgeInput {
  channel: ChannelRelateUpsertInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input EpisodeInSeriesEdgeInput {
  series: SeriesRelateUpsertInput!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input EpisodeOnPlatformEdgeInput {
  platform: PlatformRelateUpsertInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input EpisodeHasSegmentEdgeInput {
  segment: EpisodeSegmentRelateUpsertInput!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Series Edge Inputs
# ============================================================================

input SeriesInChannelEdgeInput {
  channel: ChannelRelateUpsertInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SeriesIncludesEpisodeEdgeInput {
  episode: EpisodeRelateUpsertInput!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# ============================================================================
# Upsert Inputs
# ============================================================================

input UpsertPlatformInput {
  platformId: String
  canonicalName: String!
  aliases: [String!]
  platformType: MediaPlatformType!
  description: String
  websiteUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  hostsChannel: [PlatformHostsChannelEdgeInput!]
}

input UpsertChannelInput {
  channelId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  channelHandle: String
  platformChannelId: String
  webPageUrl: String
  rssUrl: String
  imageUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  onPlatform: [PlatformOnChannelEdgeInput!]
  hasSeries: [ChannelHasSeriesEdgeInput!]
  hasEpisode: [ChannelHasEpisodeEdgeInput!]
}

input UpsertSeriesInput {
  seriesId: String
  canonicalName: String!
  aliases: [String!]
  description: String
  seriesType: MediaSeriesType!
  webPageUrl: String
  imageUrl: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  inChannel: [SeriesInChannelEdgeInput!]
  includesEpisode: [SeriesIncludesEpisodeEdgeInput!]
}

input UpsertEpisodeInput {
  episodeId: String
  canonicalName: String!
  description: String
  publishedAt: DateTime
  durationSec: Int
  language: String
  s3TranscriptUrl: String
  transcriptUrl: String
  webPageUrl: String
  webPageSummary: String
  searchText: String
  embedding: String
  youtubeUrl: String
  youtubeWatchUrl: String
  youtubeEmbedUrl: String
  socialUrlsJson: String
  timestampsJson: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  inChannel: [EpisodeInChannelEdgeInput!]
  inSeries: [EpisodeInSeriesEdgeInput!]
  onPlatform: [EpisodeOnPlatformEdgeInput!]
  hasSegment: [EpisodeHasSegmentEdgeInput!]
}

input UpsertEpisodeSegmentsInput {
  episode: EpisodeRelateUpsertInput!
  segments: [EpisodeSegmentWithOrderInput!]!
}

input EpisodeSegmentWithOrderInput {
  segment: EpisodeSegmentRelateUpsertInput!
  orderIndex: Int
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: media/02-inputs.graphql =====

# ===== BEGIN: media/03-operations.graphql =====
extend type Mutation {
  upsertPlatform(input: UpsertPlatformInput!): Platform!
  upsertChannel(input: UpsertChannelInput!): Channel!
  upsertSeries(input: UpsertSeriesInput!): Series!
  upsertEpisode(input: UpsertEpisodeInput!): Episode!
  upsertEpisodeSegments(input: UpsertEpisodeSegmentsInput!): Episode!
}
# ===== END: media/03-operations.graphql =====

# ===== BEGIN: organization_commerce/00-types.graphql =====
type Organization {
  organizationId: ID!
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!] 
  # add isActive or use validAt/invalidAt/expiredAt
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime! 

  # Searchability and Vector 
  searchText: String   
  embedding: [Float!] 
  # Relationships
  hasLocation: [HasLocationEdge!]
  ownsOrControls: [OwnsOrControlsEdge!]
  lists: [ListsEdge!]
  offersProduct: [OffersProductEdge!]
  suppliesCompoundForm: [SuppliesCompoundFormEdge!]
  manufactures: [ManufacturesEdge!]
  manufacturesProduct: [ManufacturesProductEdge!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationEdge!]
  contractManufacturerForProduct: [ContractManufacturerForProductEdge!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormEdge!]
  performsManufacturingProcess: [PerformsManufacturingProcessEdge!]
  developsPlatform: [DevelopsPlatformEdge!]
  usesPlatform: [UsesPlatformEdge!]
  # Organization -> Person relationships
  employs: [EmploysEdge!]
  foundedBy: [FoundedByEdge!]
  hasBoardMember: [HasBoardMemberEdge!]
  hasScientificAdvisor: [HasScientificAdvisorEdge!]
  hasExecutiveRole: [HasExecutiveRoleEdge!]
} 


type PhysicalLocation {
  locationId: ID!
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
} 


type ManufacturingProcess {
  manufacturingProcessId: ID!
  canonicalName: String!
  processType: ProcessType!
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type TechnologyPlatform {
  platformId: ID!
  canonicalName: String!
  aliases: [String!]
  platformType: PlatformType!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}
# ===== END: organization_commerce/00-types.graphql =====

# ===== BEGIN: organization_commerce/01-edges.graphql =====
type HasLocationEdge {
  location: PhysicalLocation!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OwnsOrControlsEdge {
  organization: Organization!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ListsEdge {
  listing: Listing!
  listRole: ListRole!
  channel: DistributionChannel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type OffersProductEdge {
  product: Product!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type SuppliesCompoundFormEdge {
  compoundForm: CompoundForm!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturesEdge {
  compoundForm: CompoundForm!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturesProductEdge {
  product: Product!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForOrganizationEdge {
  organization: Organization!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForProductEdge {
  product: Product!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ContractManufacturerForCompoundFormEdge {
  compoundForm: CompoundForm!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type PerformsManufacturingProcessEdge {
  manufacturingProcess: ManufacturingProcess!
  role: ManufacturingRole!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type DevelopsPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type UsesPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

# Organization -> Person edge types

type EmploysEdge {
  person: Person!
  roleTitle: String
  department: String
  roleFunction: String
  seniority: String
  employmentType: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type FoundedByEdge {
  person: Person!
  founderRole: String
  foundingDate: DateTime
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasBoardMemberEdge {
  person: Person!
  boardRole: String
  committee: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasScientificAdvisorEdge {
  person: Person!
  advisorType: String
  focusAreas: [String!]
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasExecutiveRoleEdge {
  person: Person!
  executiveRole: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}
# ===== END: organization_commerce/01-edges.graphql =====

# ===== BEGIN: organization_commerce/02-inputs.graphql =====
input OrganizationInput {
  organizationId: ID
  name: String!
  aliases: [String!]
  orgType: OrgType!
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  # Relationships
  hasLocation: [HasLocationRelationshipInput!]
  ownsOrControls: [OwnsOrControlsRelationshipInput!]
  lists: [ListsRelationshipInput!]
  offersProduct: [OffersProductRelationshipInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipInput!]
  manufactures: [ManufacturesRelationshipInput!]
  manufacturesProduct: [ManufacturesProductRelationshipInput!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationRelationshipInput!]
  contractManufacturerForProduct: [ContractManufacturerForProductRelationshipInput!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormRelationshipInput!]
  performsManufacturingProcess: [PerformsManufacturingProcessRelationshipInput!]
  developsPlatform: [DevelopsPlatformRelationshipInput!]
  usesPlatform: [UsesPlatformRelationshipInput!]
  employs: [EmploysRelationshipInput!]
  foundedBy: [FoundedByRelationshipInput!]
  hasBoardMember: [HasBoardMemberRelationshipInput!]
  hasScientificAdvisor: [HasScientificAdvisorRelationshipInput!]
  hasExecutiveRole: [HasExecutiveRoleRelationshipInput!]
}

input UpdateOrganizationInput {
  organizationId: ID
  name: String
  aliases: [String!]
  orgType: OrgType
  description: String
  businessModel: BusinessModel
  primaryIndustryTags: [String!]
  regionsServed: [String!]
  legalName: String
  legalStructure: String
  ownershipType: String
  jurisdictionsOfIncorporation: [String!]
  websiteUrl: String
  defaultCollectionModes: [String!]
  defaultRegionsAvailable: [String!]
  publicTicker: String
  fundingStage: String
  employeeCountMin: Int
  employeeCountMax: Int
  employeeCountAsOf: DateTime
  revenueAnnualMin: Float
  revenueAnnualMax: Float
  revenueAnnualCurrency: String
  revenueAnnualAsOf: DateTime
  valuationMin: Float
  valuationMax: Float
  valuationCurrency: String
  valuationAsOf: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  # Relationships (using update versions)
  hasLocation: [HasLocationRelationshipUpdateInput!]
  ownsOrControls: [OwnsOrControlsRelationshipUpdateInput!]
  lists: [ListsRelationshipUpdateInput!]
  offersProduct: [OffersProductRelationshipUpdateInput!]
  suppliesCompoundForm: [SuppliesCompoundFormRelationshipUpdateInput!]
  manufactures: [ManufacturesRelationshipUpdateInput!]
  manufacturesProduct: [ManufacturesProductRelationshipUpdateInput!]
  contractManufacturerForOrganization: [ContractManufacturerForOrganizationRelationshipUpdateInput!]
  contractManufacturerForProduct: [ContractManufacturerForProductRelationshipUpdateInput!]
  contractManufacturerForCompoundForm: [ContractManufacturerForCompoundFormRelationshipUpdateInput!]
  performsManufacturingProcess: [PerformsManufacturingProcessRelationshipUpdateInput!]
  developsPlatform: [DevelopsPlatformRelationshipUpdateInput!]
  usesPlatform: [UsesPlatformRelationshipUpdateInput!]
  employs: [EmploysRelationshipUpdateInput!]
  foundedBy: [FoundedByRelationshipUpdateInput!]
  hasBoardMember: [HasBoardMemberRelationshipUpdateInput!]
  hasScientificAdvisor: [HasScientificAdvisorRelationshipUpdateInput!]
  hasExecutiveRole: [HasExecutiveRoleRelationshipUpdateInput!]
}  


input PhysicalLocationInput {
  locationId: ID
  canonicalName: String!
  locationType: LocationType!
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

input PhysicalLocationRelateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
}

input PhysicalLocationRelateUpdateInput {
  create: PhysicalLocationInput
  connect: PhysicalLocationConnectInput
  update: PhysicalLocationUpdateInput
}

input PhysicalLocationConnectInput {
  locationId: ID!
} 

input PhysicalLocationUpdateInput {
  locationId: ID
  canonicalName: String
  locationType: LocationType
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  countryCode: String
  geoLat: Float
  geoLon: Float
  timezone: String
  jurisdiction: String
  placeTags: [String!]
  hoursOfOperation: String
  contactPhone: String
  contactEmail: String
}

input HasLocationRelationshipInput {
  location: PhysicalLocationRelateInput!
  locationRole: String!
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasLocationRelationshipUpdateInput {
  location: PhysicalLocationRelateUpdateInput!
  locationRole: String
  isPrimary: Boolean
  startDate: DateTime
  endDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OrganizationRelateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
}

input OrganizationRelateUpdateInput {
  create: OrganizationInput
  connect: OrganizationConnectInput
  update: UpdateOrganizationInput
}

input OrganizationConnectInput {
  organizationId: ID!
}

input OwnsOrControlsRelationshipInput {
  organization: OrganizationRelateInput!
  relationshipType: String!
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OwnsOrControlsRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  relationshipType: String
  ownershipPercent: Float
  controlType: String
  effectiveFrom: DateTime
  effectiveTo: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}  



input OffersProductRelationshipInput {
  product: ProductRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input OffersProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
} 

input SuppliesCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input SuppliesCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturingProcessRelateInput {
  create: ManufacturingProcessInput
  connect: ManufacturingProcessConnectInput
} 

input ManufacturingProcessInput {
  manufacturingProcessId: ID
  canonicalName: String!
  processType: ProcessType!
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturingProcessUpdateInput {
  manufacturingProcessId: ID
  canonicalName: String
  processType: ProcessType
  description: String
  inputs: [String!]
  outputs: [String!]
  qualityRisks: [String!]
  scalabilityLevel: ScalabilityLevel
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input TechnologyPlatformInput {
  platformId: ID
  canonicalName: String!
  aliases: [String!]
  platformType: PlatformType!
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input TechnologyPlatformUpdateInput {
  platformId: ID
  canonicalName: String
  aliases: [String!]
  platformType: PlatformType
  description: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}


input ManufacturingProcessRelateUpdateInput {
  create: ManufacturingProcessInput
  connect: ManufacturingProcessConnectInput
  update: ManufacturingProcessUpdateInput
}

input ManufacturingProcessConnectInput {
  manufacturingProcessId: ID!
}

input TechnologyPlatformRelateInput {
  create: TechnologyPlatformInput
  connect: TechnologyPlatformConnectInput
}

input TechnologyPlatformRelateUpdateInput {
  create: TechnologyPlatformInput
  connect: TechnologyPlatformConnectInput
  update: TechnologyPlatformUpdateInput
}

input TechnologyPlatformConnectInput {
  platformId: ID!
}

input ManufacturesRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesProductRelationshipInput {
  product: ProductRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturesProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForOrganizationRelationshipInput {
  organization: OrganizationRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForOrganizationRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForProductRelationshipInput {
  product: ProductRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForProductRelationshipUpdateInput {
  product: ProductRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContractManufacturerForCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PerformsManufacturingProcessRelationshipInput {
  manufacturingProcess: ManufacturingProcessRelateInput!
  role: ManufacturingRole!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PerformsManufacturingProcessRelationshipUpdateInput {
  manufacturingProcess: ManufacturingProcessRelateUpdateInput!
  role: ManufacturingRole
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DevelopsPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DevelopsPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  relationshipRole: RelationshipRole
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input UsesPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  usageContext: UsageContext
  isPrimary: Boolean
  notes: String
  source: Source
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# Organization -> Person edge inputs (EMPLOYS, FOUNDED_BY, HAS_SCIENTIFIC_ADVISOR, HAS_BOARD_MEMBER, HAS_EXECUTIVE_ROLE)

input EmploysRelationshipInput {
  person: PersonRelateInput!
  roleTitle: String
  department: String
  roleFunction: String
  seniority: String
  employmentType: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input EmploysRelationshipUpdateInput {
  person: PersonRelateUpdateInput!
  roleTitle: String
  department: String
  roleFunction: String
  seniority: String
  employmentType: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input FoundedByRelationshipInput {
  person: PersonRelateInput!
  founderRole: String
  foundingDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input FoundedByRelationshipUpdateInput {
  person: PersonRelateUpdateInput!
  founderRole: String
  foundingDate: DateTime
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasBoardMemberRelationshipInput {
  person: PersonRelateInput!
  boardRole: String
  committee: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasBoardMemberRelationshipUpdateInput {
  person: PersonRelateUpdateInput!
  boardRole: String
  committee: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasScientificAdvisorRelationshipInput {
  person: PersonRelateInput!
  advisorType: String
  focusAreas: [String!]
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasScientificAdvisorRelationshipUpdateInput {
  person: PersonRelateUpdateInput!
  advisorType: String
  focusAreas: [String!]
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasExecutiveRoleRelationshipInput {
  person: PersonRelateInput!
  executiveRole: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasExecutiveRoleRelationshipUpdateInput {
  person: PersonRelateUpdateInput!
  executiveRole: String
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: organization_commerce/02-inputs.graphql =====

# ===== BEGIN: organization_commerce/03-operations.graphql =====
extend type Mutation { 
 createOrganization(input: OrganizationInput!): Organization!
  updateOrganization(input: UpdateOrganizationInput!): Organization! 
} 

extend type Query { 
 organizations: [Organization!]! 
 searchOrganizations(input: OrganizationSearchInput!): OrganizationSearchResult!
}
# ===== END: organization_commerce/03-operations.graphql =====

# ===== BEGIN: people/00-types.graphql =====
type Person {
  personId: ID!
  canonicalName: String!
  givenName: String
  familyName: String
  middleName: String
  suffix: String
  honorific: String
  aliases: [String!]
  bio: String
  primaryLanguage: String
  primaryDomain: String
  specialties: [String!]
  expertiseTags: [String!]
  affiliationSummary: String
  degrees: [String!]
  credentialIds: [String!]
  orcid: String
  npi: String
  licenseIds: [String!]
  websiteUrl: String
  email: String
  socialProfiles: [String!]
  linkedinUrl: String
  twitterUrl: String
  githubUrl: String
  scholarUrl: String
  headshotUrl: String
  publicFigure: Boolean
  notabilityNotes: String
  createdAt: DateTime!
  updatedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  searchText: String
  embedding: [Float!]
  hasRoleOnChannel: [PersonHasRoleOnChannelEdge!]
  appearsInEpisode: [PersonAppearsInEpisodeEdge!]
}
# ===== END: people/00-types.graphql =====

# ===== BEGIN: people/01-edges.graphql =====
# ============================================================================
# Person ↔ Media Edges
# ============================================================================

type PersonHasRoleOnChannelEdge {
  channel: Channel!
  role: ChannelRole!
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  typicalAppearance: TypicalAppearance
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type PersonAppearsInEpisodeEdge {
  episode: Episode!
  appearanceRole: AppearanceRole!
  billingOrder: Int
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: people/01-edges.graphql =====

# ===== BEGIN: people/02-inputs.graphql =====
input PersonConnectInput {
  personId: ID!
}

# ============================================================================
# Person ↔ Media Edge Inputs
# ============================================================================

input PersonHasRoleOnChannelEdgeInput {
  channel: ChannelRelateUpsertInput!
  role: ChannelRole
  startDate: DateTime
  endDate: DateTime
  isCurrent: Boolean
  typicalAppearance: TypicalAppearance
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PersonAppearsInEpisodeEdgeInput {
  episode: EpisodeRelateUpsertInput!
  appearanceRole: AppearanceRole
  billingOrder: Int
  confidence: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input PersonInput {
  personId: ID
  canonicalName: String!
  givenName: String
  familyName: String
  middleName: String
  suffix: String
  honorific: String
  aliases: [String!]
  bio: String
  primaryLanguage: String
  primaryDomain: String
  specialties: [String!]
  expertiseTags: [String!]
  affiliationSummary: String
  degrees: [String!]
  credentialIds: [String!]
  orcid: String
  npi: String
  licenseIds: [String!]
  websiteUrl: String
  email: String
  socialProfiles: [String!]
  linkedinUrl: String
  twitterUrl: String
  githubUrl: String
  scholarUrl: String
  headshotUrl: String
  publicFigure: Boolean
  notabilityNotes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  searchText: String
  hasRoleOnChannel: [PersonHasRoleOnChannelEdgeInput!]
  appearsInEpisode: [PersonAppearsInEpisodeEdgeInput!]
}

input PersonUpdateInput {
  personId: ID
  canonicalName: String
  givenName: String
  familyName: String
  middleName: String
  suffix: String
  honorific: String
  aliases: [String!]
  bio: String
  primaryLanguage: String
  primaryDomain: String
  specialties: [String!]
  expertiseTags: [String!]
  affiliationSummary: String
  degrees: [String!]
  credentialIds: [String!]
  orcid: String
  npi: String
  licenseIds: [String!]
  websiteUrl: String
  email: String
  socialProfiles: [String!]
  linkedinUrl: String
  twitterUrl: String
  githubUrl: String
  scholarUrl: String
  headshotUrl: String
  publicFigure: Boolean
  notabilityNotes: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  searchText: String
  hasRoleOnChannel: [PersonHasRoleOnChannelEdgeInput!]
  appearsInEpisode: [PersonAppearsInEpisodeEdgeInput!]
}

input PersonRelateInput {
  create: PersonInput
  connect: PersonConnectInput
}

input PersonRelateUpdateInput {
  create: PersonInput
  connect: PersonConnectInput
  update: PersonUpdateInput
}
# ===== END: people/02-inputs.graphql =====

# ===== BEGIN: people/03-operations.graphql =====

# ===== END: people/03-operations.graphql =====

# ===== BEGIN: products_listings/00-types.graphql =====
type Listing {
  listingId: ID!
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

type Product {
  productId: ID!
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  productFingerprint: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime! 

  # Searchability and Vector 

  searchText: String   
  embedding: [Float!] 
  # Relationships
  deliversLabTest: [DeliversLabTestEdge!]
  implementsPanel: [ImplementsPanelEdge!]
  containsCompoundForm: [ContainsCompoundFormEdge!]
  followsPathway: [FollowsPathwayEdge!]
  inCategory: [InCategoryEdge!]
  usesPlatform: [ProductUsesPlatformEdge!]
  hasRegulatoryStatus: [HasRegulatoryStatusEdge!]
  manufacturedBy: [ManufacturedByEdge!]
  isDevice: [ProductIsDeviceEdge!]
} 

type RegulatoryStatus {
  regulatoryStatusId: ID!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type RegulatoryPathway {
  pathwayId: ID!
  authority: String!
  pathwayType: String!
  pathwayName: String!
  requirementsSummary: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}  


type ProductCategory {
  categoryId: ID!
  name: String!
  description: String
  aliases: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}
# ===== END: products_listings/00-types.graphql =====

# ===== BEGIN: products_listings/01-edges.graphql =====
type DeliversLabTestEdge {
  labTest: LabTest!
  role: LabTestRole!
  quantity: Int
  componentName: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ImplementsPanelEdge {
  panelDefinition: PanelDefinition!
  panelRole: PanelRole
  versionLabel: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
} 


type ContainsCompoundFormEdge {
  compoundForm: CompoundForm!
  dose: Float
  doseUnit: String
  role: CompoundFormRole
  standardizedTo: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type FollowsPathwayEdge {
  regulatoryPathway: RegulatoryPathway!
  jurisdictionId: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type InCategoryEdge {
  productCategory: ProductCategory!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ProductUsesPlatformEdge {
  technologyPlatform: TechnologyPlatform!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type HasRegulatoryStatusEdge {
  regulatoryStatus: RegulatoryStatus!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ManufacturedByEdge {
  organization: Organization!
  claimIds: [String!]!
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}

type ProductIsDeviceEdge {
  device: Device!
  sku: String
  region: String
  startAt: DateTime
  endAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
}
# ===== END: products_listings/01-edges.graphql =====

# ===== BEGIN: products_listings/02-inputs.graphql =====
input ListingInput {
  listingId: ID
  listingDomain: ListingDomain!
  title: String!
  description: String
  sku: String
  url: String
  brandName: String
  currency: String!
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}

input ProductInput {
  productId: ID
  name: String!
  synonyms: [String!]
  productDomain: ProductDomain!
  productType: String
  productFingerprint: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
  # Relationships
  deliversLabTest: [DeliversLabTestRelationshipInput!]
  implementsPanel: [ImplementsPanelRelationshipInput!]
  containsCompoundForm: [ContainsCompoundFormRelationshipInput!]
  followsPathway: [FollowsPathwayRelationshipInput!]
  inCategory: [InCategoryRelationshipInput!]
  usesPlatform: [ProductUsesPlatformRelationshipInput!]
  hasRegulatoryStatus: [HasRegulatoryStatusRelationshipInput!]
  manufacturedBy: [ManufacturedByRelationshipInput!]
  isDevice: [ProductIsDeviceRelationshipInput!]
} 



input ListingRelateInput {
  create: ListingInput
  connect: ListingConnectInput
}

input ListingRelateUpdateInput {
  create: ListingInput
  connect: ListingConnectInput
  update: ListingUpdateInput
}

input ListingConnectInput {
  listingId: ID!
}

input ListsRelationshipInput {
  listing: ListingRelateInput!
  listRole: ListRole!
  channel: DistributionChannel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
} 

input ListingUpdateInput {
  listingId: ID
  listingDomain: ListingDomain
  title: String
  description: String
  sku: String
  url: String
  brandName: String
  currency: String
  priceAmount: Float
  priceType: PriceType
  pricingNotes: String
  constraints: String
  regionsAvailable: [String!]
  requiresAppointment: Boolean
  collectionMode: CollectionMode
  turnaroundTime: String
}


input ProductUpdateInput {
  productId: ID
  name: String
  synonyms: [String!]
  productDomain: ProductDomain
  productType: String
  productFingerprint: String
  intendedUse: String
  description: String
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String
  riskClass: String
  currency: String
  priceAmount: Float
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  # Relationships (using update versions)
  deliversLabTest: [DeliversLabTestRelationshipUpdateInput!]
  implementsPanel: [ImplementsPanelRelationshipUpdateInput!]
  containsCompoundForm: [ContainsCompoundFormRelationshipUpdateInput!]
  followsPathway: [FollowsPathwayRelationshipUpdateInput!]
  inCategory: [InCategoryRelationshipUpdateInput!]
  usesPlatform: [ProductUsesPlatformRelationshipUpdateInput!]
  hasRegulatoryStatus: [HasRegulatoryStatusRelationshipUpdateInput!]
  manufacturedBy: [ManufacturedByRelationshipUpdateInput!]
  isDevice: [ProductIsDeviceRelationshipInput!]
}

input ListsRelationshipUpdateInput {
  listing: ListingRelateUpdateInput!
  listRole: ListRole
  channel: DistributionChannel
  regionsOverrides: [String!]
  collectionModesOverrides: [String!]
  availabilityNotes: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductRelateInput {
  create: ProductInput
  connect: ProductConnectInput
}

input ProductRelateUpdateInput {
  create: ProductInput
  connect: ProductConnectInput
  update: ProductUpdateInput
}

input ProductConnectInput {
  productId: ID!
}  

input ProductCategoryInput {
  categoryId: ID
  name: String!
  description: String
  aliases: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
} 

input ProductCategoryUpdateInput {
  categoryId: ID
  name: String
  description: String
  aliases: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductCategoryRelateInput {
  create: ProductCategoryInput
  connect: ProductCategoryConnectInput
}

input ProductCategoryRelateUpdateInput {
  create: ProductCategoryInput
  connect: ProductCategoryConnectInput
  update: ProductCategoryUpdateInput
}

input ProductCategoryConnectInput {
  categoryId: ID!
}  


input DeliversLabTestRelationshipInput {
  labTest: LabTestRelateInput!
  role: LabTestRole!
  quantity: Int
  componentName: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input DeliversLabTestRelationshipUpdateInput {
  labTest: LabTestRelateUpdateInput!
  role: LabTestRole
  quantity: Int
  componentName: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ImplementsPanelRelationshipInput {
  panelDefinition: PanelDefinitionRelateInput!
  panelRole: PanelRole
  versionLabel: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ImplementsPanelRelationshipUpdateInput {
  panelDefinition: PanelDefinitionRelateUpdateInput!
  panelRole: PanelRole
  versionLabel: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContainsCompoundFormRelationshipInput {
  compoundForm: CompoundFormRelateInput!
  dose: Float
  doseUnit: String
  role: CompoundFormRole
  standardizedTo: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ContainsCompoundFormRelationshipUpdateInput {
  compoundForm: CompoundFormRelateUpdateInput!
  dose: Float
  doseUnit: String
  role: CompoundFormRole
  standardizedTo: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input FollowsPathwayRelationshipInput {
  regulatoryPathway: RegulatoryPathwayRelateInput!
  jurisdictionId: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input FollowsPathwayRelationshipUpdateInput {
  regulatoryPathway: RegulatoryPathwayRelateUpdateInput!
  jurisdictionId: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input InCategoryRelationshipInput {
  productCategory: ProductCategoryRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input InCategoryRelationshipUpdateInput {
  productCategory: ProductCategoryRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductUsesPlatformRelationshipInput {
  technologyPlatform: TechnologyPlatformRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ProductUsesPlatformRelationshipUpdateInput {
  technologyPlatform: TechnologyPlatformRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input HasRegulatoryStatusRelationshipInput {
  regulatoryStatus: RegulatoryStatusRelateInput!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
input HasRegulatoryStatusRelationshipUpdateInput {
  regulatoryStatus: RegulatoryStatusRelateUpdateInput!
  status: String
  effectiveDate: DateTime
  statusDetails: String
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturedByRelationshipInput {
  organization: OrganizationRelateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input ManufacturedByRelationshipUpdateInput {
  organization: OrganizationRelateUpdateInput!
  claimIds: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

# Product -[:IS_A_DEVICE]-> Device (uses DeviceRelateUpsertInput from devices_modalities)
input ProductIsDeviceRelationshipInput {
  device: DeviceRelateUpsertInput!
  sku: String
  region: String
  startAt: DateTime
  endAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}


# Regulatory moved to product_listings inputs 

input RegulatoryStatusRelateInput {
  create: RegulatoryStatusInput
  connect: RegulatoryStatusConnectInput
}

input RegulatoryStatusRelateUpdateInput {
  create: RegulatoryStatusInput
  connect: RegulatoryStatusConnectInput
  update: RegulatoryStatusUpdateInput
}

input RegulatoryStatusConnectInput {
  regulatoryStatusId: ID!
}

input RegulatoryPathwayRelateInput {
  create: RegulatoryPathwayInput
  connect: RegulatoryPathwayConnectInput
}

input RegulatoryPathwayRelateUpdateInput {
  create: RegulatoryPathwayInput
  connect: RegulatoryPathwayConnectInput
  update: RegulatoryPathwayUpdateInput
}

input RegulatoryPathwayConnectInput {
  pathwayId: ID!
}  

input RegulatoryStatusInput {
  regulatoryStatusId: ID
  status: String
  effectiveDate: DateTime
  statusDetails: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RegulatoryPathwayInput {
  pathwayId: ID
  authority: String!
  pathwayType: String!
  pathwayName: String!
  requirementsSummary: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
} 

input RegulatoryStatusUpdateInput {
  regulatoryStatusId: ID
  status: String
  effectiveDate: DateTime
  statusDetails: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

input RegulatoryPathwayUpdateInput {
  pathwayId: ID
  authority: String
  pathwayType: String
  pathwayName: String
  requirementsSummary: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: products_listings/02-inputs.graphql =====

# ===== BEGIN: products_listings/03-operations.graphql =====
extend type Mutation { 
 createProduct(input: ProductInput!): Product!
  updateProduct(input: ProductUpdateInput!): Product! 
} 

extend type Query {  
     products: [Product!]! 

}
# ===== END: products_listings/03-operations.graphql =====

# ===== BEGIN: search/00-types.graphql =====
type SearchReason {
  kind: SearchReasonKind!
  field: String
  value: String
  score: Float
  detail: String
} 

type AutocompleteItem {
  id: ID!
  label: String!
  subtitle: String
}  


type OrganizationSearchHit {
  node: Organization!
  score: Float
  reasons: [SearchReason!]
}

type OrganizationSearchResult {
  items: [OrganizationSearchHit!]!
  pageInfo: PageInfo!
} 

type ProductSearchHit {
  node: Product!
  score: Float
  reasons: [SearchReason!]
}

type ProductSearchResult {
  items: [ProductSearchHit!]!
  pageInfo: PageInfo!
} 

type SearchSurface {
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
}
# ===== END: search/00-types.graphql =====

# ===== BEGIN: search/01-edges.graphql =====

# ===== END: search/01-edges.graphql =====

# ===== BEGIN: search/02-inputs.graphql =====
input OrganizationFilterInput {
  orgTypeIn: [OrgType!]
  businessModelIn: [BusinessModel!]

  regionsServedAny: [String!]
  primaryIndustryTagsAny: [String!]

  publicTicker: String

  employeeCountMinGte: Int
  employeeCountMaxLte: Int

  """
  Optional: if you materialize isActive on the node.
  If you don't store it yet, ignore this field in resolvers (or treat null as no-op).
  """
  isActive: Boolean
}


input OrganizationSortInput {
  field: OrganizationSortField!
  direction: SortDirection! = DESC
}

input OrganizationSearchInput {
  """
  Query text. If omitted/empty, FIELD_ONLY mode is usually used.
  """
  q: String

  mode: SearchMode = HYBRID

  filter: OrganizationFilterInput

  """
  Sort is only guaranteed to be respected when mode=FIELD_ONLY or q is empty.
  Ranked modes (FULLTEXT/VECTOR/HYBRID) primarily sort by score.
  """
  sort: OrganizationSortInput

  page: PageInput = { first: 20 }

  """
  When true, return score reasons (why it matched).
  Off by default to keep responses small/fast.
  """
  explain: Boolean = false
} 


input ProductFilterInput {
  productDomainIn: [ProductDomain!]
  riskClassIn: [String!]

  currency: String
  priceAmountGte: Float
  priceAmountLte: Float

  # Identifier exact matches
  brandName: String
  modelNumber: String
  ndcCode: String
  upc: String
  gtin: String

  isActive: Boolean
}


input ProductSortInput {
  field: ProductSortField!
  direction: SortDirection! = DESC
}

input ProductSearchInput {
  q: String
  mode: SearchMode = HYBRID

  filter: ProductFilterInput
  sort: ProductSortInput

  page: PageInput = { first: 20 }
  explain: Boolean = false
} 

input SearchSurfaceInput {
  searchText: String
  searchTextEmbedding: [Float!]
  searchTextModel: String
  searchTextVersion: String
  searchTextUpdatedAt: DateTime
}
# ===== END: search/02-inputs.graphql =====

# ===== BEGIN: search/03-operations.graphql =====

# ===== END: search/03-operations.graphql =====

# ===== BEGIN: studies/00-types.graphql =====
type Study {
  studyId: ID!
  registrySource: String
  registryId: String
  doi: String
  internalStudyCode: String
  canonicalTitle: String!
  studyKind: StudyKind!
  shortTitle: String
  aliases: [String!]
  designKind: DesignKind
  status: StudyStatus
  phase: String
  sampleSize: Int
  randomized: Boolean
  blinded: BlindedKind
  comparatorType: ComparatorType
  keywords: [String!]
  locations: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime!
  # Relationships
  evaluates: [StudyEvaluatesEdge!]
  sponsoredBy: [StudySponsoredByEdge!]
  runBy: [StudyRunByEdge!]
  investigatedBy: [StudyInvestigatedByEdge!]
  studiesPopulations: [StudyStudiesPopulationEdge!]
  hasDatasets: [StudyHasDatasetEdge!]
  investigatesConditions: [StudyInvestigatesConditionEdge!]
  hasOutcomes: [StudyHasOutcomeEdge!]
} 


type Population {
  populationId: ID!
  name: String
  populationKind: PopulationKind!
  species: String
  strain: String
  cellLine: String
  diseaseState: String
  ageMin: Int
  ageMax: Int
  ageUnit: String
  sex: Sex
  n: Int
  inclusionCriteria: [String!]
  exclusionCriteria: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type Dataset {
  datasetId: ID!
  name: String!
  description: String
  datasetKind: DatasetKind!
  format: String
  license: String
  accessLevel: DatasetAccessLevel
  sourceSystem: String
  uri: String
  checksum: String
  version: String
  publishedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type StudyOutcome {
  studyOutcomeId: ID!
  canonicalName: String!
  displayName: String
  aliases: [String!]
  description: String
  outcomeCategory: OutcomeCategory!
  polarityHint: PolarityHint
  domain: OutcomeDomain
  measurementType: OutcomeMeasurementType
  unit: String
  biologicalMatrix: String
  analyte: String
  timeHorizon: String
  standardSystem: String
  standardCode: String
  standardLabel: String
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type Condition {
  conditionId: ID!
  name: String!
  aliases: [String!]
  description: String
  icdCodes: [String!]
  snomedCodes: [String!]
  meshTerms: [String!]
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: studies/00-types.graphql =====

# ===== BEGIN: studies/01-edges.graphql =====
type StudyEvaluatesEdge {
  targetKind: EvaluatesTargetKind!
  product: Product
  compoundForm: CompoundForm
  compoundId: ID
  foodId: ID
  foodVariantId: ID
  role: StudyEvaluatesRole!
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
} 



type StudySponsoredByEdge {
  organization: Organization!
  role: StudySponsorRole
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type StudyRunByEdge {
  organization: Organization!
  role: StudyRunByRole
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type StudyInvestigatedByEdge {
  person: Person!
  role: StudyInvestigatorRole
  affiliation: String
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type StudyStudiesPopulationEdge {
  population: Population!
  role: StudyPopulationRole
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type StudyHasDatasetEdge {
  dataset: Dataset!
  role: StudyDatasetRole
  accessNotes: String
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type StudyInvestigatesConditionEdge {
  condition: Condition!
  role: StudyInvestigatesRole
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}

type StudyHasOutcomeEdge {
  outcome: StudyOutcome!
  priority: StudyOutcomePriority!
  role: StudyOutcomeRole
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
  validAt: DateTime
  invalidAt: DateTime
  expiredAt: DateTime
  createdAt: DateTime
}
# ===== END: studies/01-edges.graphql =====

# ===== BEGIN: studies/02-inputs.graphql =====
input UpsertStudyInput {
  id: ID
  registrySource: String
  registryId: String
  doi: String
  internalStudyCode: String
  canonicalTitle: String
  studyKind: StudyKind!
  shortTitle: String
  aliases: [String!]
  designKind: DesignKind
  status: StudyStatus
  phase: String
  sampleSize: Int
  randomized: Boolean
  blinded: BlindedKind
  comparatorType: ComparatorType
  keywords: [String!]
  locations: [String!]
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input EdgeAuditInput {
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
  strength: Float
  extractorVersion: String
  extractedAt: DateTime
} 


input PopulationConnectInput {
  populationId: ID!
}

input PopulationInput {
  populationId: ID
  name: String
  populationKind: PopulationKind!
  species: String
  strain: String
  cellLine: String
  diseaseState: String
  ageMin: Int
  ageMax: Int
  ageUnit: String
  sex: Sex
  n: Int
  inclusionCriteria: [String!]
  exclusionCriteria: [String!]
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input PopulationRelateInput {
  create: PopulationInput
  connect: PopulationConnectInput
}

input DatasetConnectInput {
  datasetId: ID!
}

input DatasetInput {
  datasetId: ID
  name: String!
  description: String
  datasetKind: DatasetKind!
  format: String
  license: String
  accessLevel: DatasetAccessLevel
  sourceSystem: String
  uri: String
  checksum: String
  version: String
  publishedAt: DateTime
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input DatasetRelateInput {
  create: DatasetInput
  connect: DatasetConnectInput
}

input StudyOutcomeConnectInput {
  studyOutcomeId: ID!
}

input StudyOutcomeInput {
  studyOutcomeId: ID
  canonicalName: String!
  displayName: String
  aliases: [String!]
  description: String
  outcomeCategory: OutcomeCategory!
  polarityHint: PolarityHint
  domain: OutcomeDomain
  measurementType: OutcomeMeasurementType
  unit: String
  biologicalMatrix: String
  analyte: String
  timeHorizon: String
  standardSystem: String
  standardCode: String
  standardLabel: String
  validAt: DateTime!
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input StudyOutcomeRelateInput {
  create: StudyOutcomeInput
  connect: StudyOutcomeConnectInput
}

input ConditionConnectInput {
  conditionId: ID!
}

input ConditionInput {
  conditionId: ID
  name: String!
  aliases: [String!]
  description: String
  icdCodes: [String!]
  snomedCodes: [String!]
  meshTerms: [String!]
  validAt: DateTime
  expiredAt: DateTime
  invalidAt: DateTime
  createdAt: DateTime
}

input ConditionRelateInput {
  create: ConditionInput
  connect: ConditionConnectInput
}

"""
Discriminated union input for Study EVALUATES target.
Set `kind` and provide exactly one connect-ID or create-payload matching that kind.
"""
input EvaluatesTargetRefInput {
  kind: EvaluatesTargetKind!
  # Connect IDs — provide exactly one matching `kind`
  productId: ID
  compoundId: ID
  compoundFormId: ID
  foodId: ID
  foodVariantId: ID
  # Create payloads — provide at most one matching `kind`
  createProduct: ProductRelateInput
  createCompoundForm: CompoundFormRelateInput
}

input StudyEvaluatesRelationshipInput {
  target: EvaluatesTargetRefInput!
  role: StudyEvaluatesRole!
  audit: EdgeAuditInput!
}

input StudySponsoredByRelationshipInput {
  organization: OrganizationRelateInput!
  role: StudySponsorRole
  audit: EdgeAuditInput!
}

input StudyRunByRelationshipInput {
  organization: OrganizationRelateInput!
  role: StudyRunByRole
  audit: EdgeAuditInput!
}

input StudyInvestigatedByRelationshipInput {
  person: PersonRelateInput!
  role: StudyInvestigatorRole
  affiliation: String
  audit: EdgeAuditInput!
}

input StudyStudiesPopulationRelationshipInput {
  population: PopulationRelateInput!
  role: StudyPopulationRole
  audit: EdgeAuditInput!
}

input StudyHasDatasetRelationshipInput {
  dataset: DatasetRelateInput!
  role: StudyDatasetRole
  accessNotes: String
  audit: EdgeAuditInput!
}

input StudyInvestigatesConditionRelationshipInput {
  condition: ConditionRelateInput!
  role: StudyInvestigatesRole
  audit: EdgeAuditInput!
}

input StudyHasOutcomeRelationshipInput {
  outcome: StudyOutcomeRelateInput!
  priority: StudyOutcomePriority!
  role: StudyOutcomeRole
  audit: EdgeAuditInput!
}

"""
Bundle upsert for Study (CaseStudy).
Resolver key order: id -> (registrySource + registryId) -> doi -> internalStudyCode.
All edge arrays are create-or-connect only (no update on edges).
"""
input UpsertCaseStudyInput {
  study: UpsertStudyInput!
  evaluates: [StudyEvaluatesRelationshipInput!]
  sponsoredBy: [StudySponsoredByRelationshipInput!]
  runBy: [StudyRunByRelationshipInput!]
  investigatedBy: [StudyInvestigatedByRelationshipInput!]
  studiesPopulations: [StudyStudiesPopulationRelationshipInput!]
  hasDatasets: [StudyHasDatasetRelationshipInput!]
  investigatesConditions: [StudyInvestigatesConditionRelationshipInput!]
  hasOutcomes: [StudyHasOutcomeRelationshipInput!]
}
# ===== END: studies/02-inputs.graphql =====

# ===== BEGIN: studies/03-operations.graphql =====
extend type Mutation { 
    upsertCaseStudy(input: UpsertCaseStudyInput!): Study!
}
# ===== END: studies/03-operations.graphql =====

